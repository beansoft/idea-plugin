<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8">  <meta name="built-on" content="2022-09-29T19:15:56.5311843"><meta name="build-number" content="${buildNumber}">    <meta name="keywords" content="">  <title>UAST - Unified Abstract Syntax Tree | IntelliJ Platform Plugin SDK</title><script id="virtual-toc-data" type="application/json">[{"id":"motivation","level":0,"title":"Motivation","anchor":"#motivation"},{"id":"working-with-uast","level":0,"title":"Working with UAST","anchor":"#working-with-uast"},{"id":"uast-visitors","level":0,"title":"UAST Visitors","anchor":"#uast-visitors"},{"id":"uast-performance-hints","level":0,"title":"UAST Performance Hints","anchor":"#uast-performance-hints"},{"id":"uast-caveats","level":0,"title":"UAST Caveats","anchor":"#uast-caveats"},{"id":"using-uast-in-plugins","level":0,"title":"Using UAST in Plugins","anchor":"#using-uast-in-plugins"}]</script>   <link href="https://resources.jetbrains.com/storage/help-app/v5/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content="https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png"><!-- Open Graph --><meta property="og:title" content="UAST - Unified Abstract Syntax Tree | IntelliJ Platform Plugin SDK"/><meta property="og:description" content=""/><meta property="og:image" content="https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png"/><meta property="og:site_name" content="IntelliJ Platform Plugin SDK Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="https://plugins.jetbrains.com/docs/intellij/uast.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@JBPlatform"><meta name="twitter:title" content="UAST - Unified Abstract Syntax Tree | IntelliJ Platform Plugin SDK"><meta name="twitter:description" content=""><meta name="twitter:creator" content="@JBPlatform"><meta name="twitter:image:src" content="https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png"><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "https://plugins.jetbrains.com/docs/intellij/uast.html#webpage", "url": "https://plugins.jetbrains.com/docs/intellij/uast.html", "name": "UAST - Unified Abstract Syntax Tree | IntelliJ Platform Plugin SDK", "description": "", "image": "https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "https://plugins.jetbrains.com/docs/intellij/#website", "url": "https://plugins.jetbrains.com/docs/intellij/", "name": "IntelliJ Platform Plugin SDK Help" }</script><!-- End Schema.org --></head>    <body data-id="uast.md" data-main-title="UAST - Unified Abstract Syntax Tree" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="Part IV — PSI"  data-edit-url="https://github.com/JetBrains/intellij-sdk-docs/edit/main/topics/basics/architectural_overview/uast.md"  >  <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>IntelliJ Platform Plugin SDK  Help</h3><div class="shortcuts-switcher"><label for="switch-shortcuts">Keymap:</label><select class="select _shortcuts" height="1" id="switch-shortcuts">      </select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="uast.md" id="uast.md"  >UAST - Unified Abstract Syntax Tree</h1><p id="5adc24a0_240" >UAST (Unified Abstract Syntax Tree) is an abstraction layer on the <a href="psi-elements.html" id="5adc24a0_241" data-tooltip="A PSI (Program Structure Interface) file represents a hierarchy of PSI elements (so-called PSI trees). A single PSI file (itself being a PSI element) may expose several PSI trees in specific programming languages (see ). A PSI element, in its turn, can have child PSI elements."  >PSI</a> of different JVM languages. It provides a unified API for working with common language elements like classes and method declarations, literal values, and control flow operators.</p><section class="chapter"  ><h2 id="motivation" data-toc="motivation"  >Motivation</h2><p id="5adc24a0_242" >Different JVM languages have their own <a href="psi-elements.html" id="5adc24a0_243" data-tooltip="A PSI (Program Structure Interface) file represents a hierarchy of PSI elements (so-called PSI trees). A single PSI file (itself being a PSI element) may expose several PSI trees in specific programming languages (see ). A PSI element, in its turn, can have child PSI elements."  >PSI</a>, but many IDE features like inspections, gutter markers, reference injection, and many others work the same way for all these languages.</p><p id="5adc24a0_244" >Using UAST allows providing features that will work across all <a href="#which-languages-are-supported" id="5adc24a0_245" data-tooltip="Java: full support Kotlin: full support Scala: beta, but full support Groovy: declarations only, method bodies not supported"  >supported JVM languages</a> using a single implementation.</p><p id="5adc24a0_246" >Presentation <a href="https://www.youtube.com/watch?v=j2tvi4GbOr4" id="5adc24a0_247"   data-external="true" rel="noopener noreferrer" >Writing IntelliJ Plugins for Kotlin</a> offers a thorough overview of using UAST in real-world scenarios.</p><section class="chapter"  ><h3 id="when-should-i-use-uast" data-toc="when-should-i-use-uast"  >When should I use UAST?</h3><p id="5adc24a0_248" >For plugins, that should work for all JVM languages in the same way.</p><p id="5adc24a0_249" >Some known examples are:</p><ul class="list _ul" id="5adc24a0_250"    ><li class="list__item" id="5adc24a0_251" ><p><a href="spring-api.html" id="5adc24a0_252" data-tooltip="Spring API allows 3rd party plugins to re-use, integrate with or extend existing Spring Framework support in IntelliJ IDEA Ultimate."  >Spring Framework</a></p></li><li class="list__item" id="5adc24a0_253" ><p><a href="android-studio.html" id="5adc24a0_254" data-tooltip="Android Studio plugins extend or add functionality to the Android Studio IDE. Plugins can be written in Kotlin or Java, or a mix of both, and are created using IntelliJ IDEA and the IntelliJ Platform. It's also helpful to be familiar with Java Swing. Once completed, plugins can be…"  >Android Studio</a></p></li><li class="list__item" id="5adc24a0_255" ><p><a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/plugins/devkit/devkit-core" id="5adc24a0_256"   data-external="true" rel="noopener noreferrer" >Plugin DevKit</a></p></li></ul></section><section class="chapter"  ><h3 id="which-languages-are-supported" data-toc="which-languages-are-supported"  >Which languages are supported?</h3><ul class="list _ul" id="5adc24a0_257"    ><li class="list__item" id="5adc24a0_258" ><p>Java: full support</p></li><li class="list__item" id="5adc24a0_259" ><p>Kotlin: full support</p></li><li class="list__item" id="5adc24a0_260" ><p>Scala: beta, but full support</p></li><li class="list__item" id="5adc24a0_261" ><p>Groovy: declarations only, method bodies not supported</p></li></ul></section><section class="chapter"  ><h3 id="what-about-modifying-psi" data-toc="what-about-modifying-psi"  >What about modifying PSI?</h3><p id="5adc24a0_262" >UAST is a read-only API. There are experimental <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/uast/uast-common/src/org/jetbrains/uast/generate/UastCodeGenerationPlugin.kt" id="5adc24a0_263"   data-external="true" rel="noopener noreferrer" ><code class="code " id="5adc24a0_264"  >UastCodeGenerationPlugin</code></a> and <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/java/java-analysis-api/src/com/intellij/lang/jvm/actions/JvmElementActionsFactory.kt" id="5adc24a0_265"   data-external="true" rel="noopener noreferrer" ><code class="code " id="5adc24a0_266"  >JvmElementActionsFactory</code></a> classes, but they are currently not recommended for external usage.</p></section></section><section class="chapter"  ><h2 id="working-with-uast" data-toc="working-with-uast"  >Working with UAST</h2><p id="5adc24a0_267" >The base element of UAST is <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/uast/uast-common/src/org/jetbrains/uast/baseElements/UElement.kt" id="5adc24a0_268"   data-external="true" rel="noopener noreferrer" ><code class="code " id="5adc24a0_269"  >UElement</code></a>. All common base sub-interfaces are located in the <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/uast/uast-common/src/org/jetbrains/uast/declarations" id="5adc24a0_270"   data-external="true" rel="noopener noreferrer" >declarations</a> and <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/uast/uast-common/src/org/jetbrains/uast/expressions" id="5adc24a0_271"   data-external="true" rel="noopener noreferrer" >expressions</a> directories of the <span class="control" id="5adc24a0_272" >uast</span> module.</p><p id="5adc24a0_273" >All these sub-interfaces provide methods to get the information about common syntax elements: <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/uast/uast-common/src/org/jetbrains/uast/declarations/UClass.kt" id="5adc24a0_274"   data-external="true" rel="noopener noreferrer" ><code class="code " id="5adc24a0_275"  >UClass</code></a> about class declarations, <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/uast/uast-common/src/org/jetbrains/uast/controlStructures/UIfExpression.kt" id="5adc24a0_276"   data-external="true" rel="noopener noreferrer" ><code class="code " id="5adc24a0_277"  >UIfExpression</code></a> about conditional expressions, and so on.</p><section class="chapter"  ><h3 id="psi-to-uast-conversion" data-toc="psi-to-uast-conversion"  >PSI to UAST Conversion</h3><p id="5adc24a0_278" >To obtain UAST for given <code class="code " id="5adc24a0_279"  >PsiElement</code> of one of supported languages, use <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/uast/uast-common/src/org/jetbrains/uast/UastContext.kt" id="5adc24a0_280"   data-external="true" rel="noopener noreferrer" ><code class="code " id="5adc24a0_281"  >UastFacade</code></a> class or <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/uast/uast-common/src/org/jetbrains/uast/UastContext.kt" id="5adc24a0_282"   data-external="true" rel="noopener noreferrer" ><code class="code " id="5adc24a0_283"  >UastContextKt.toUElement()</code></a>:</p><div class="tabs" id="5adc24a0_284"data-group="languages"><div class="tabs__content" data-gtm="tab" id="5adc24a0_285" data-sync-tabs="java"  data-title="Java" ><div class="code-block" data-lang="java"    data-title="Java"     >
UastContextKt.toUElement(element);
</div></div><div class="tabs__content" data-gtm="tab" id="5adc24a0_287" data-sync-tabs="kotlin"  data-title="Kotlin" ><div class="code-block" data-lang="kotlin"    data-title="Kotlin"     >
element.toUElement()
</div></div></div><p id="5adc24a0_289" >To convert <code class="code " id="5adc24a0_290"  >PsiElement</code> to the specific <code class="code " id="5adc24a0_291"  >UElement</code>, use one of the following approaches:</p><ul class="list _ul" id="5adc24a0_292"    ><li class="list__item" id="5adc24a0_293" ><p id="5adc24a0_294" >for simple conversion:</p><div class="tabs" id="5adc24a0_295"data-group="languages"><div class="tabs__content" data-gtm="tab" id="5adc24a0_296" data-sync-tabs="java"  data-title="Java" ><div class="code-block" data-lang="java"    data-title="Java"     >
UastContextKt.toUElement(element, UCallExpression.class);
</div></div><div class="tabs__content" data-gtm="tab" id="5adc24a0_298" data-sync-tabs="kotlin"  data-title="Kotlin" ><div class="code-block" data-lang="kotlin"    data-title="Kotlin"     >
element.toUElement(UCallExpression::class.java)
</div></div></div></li><li class="list__item" id="5adc24a0_300" ><p id="5adc24a0_301" >for conversion to one of different given options:</p><div class="tabs" id="5adc24a0_302"data-group="languages"><div class="tabs__content" data-gtm="tab" id="5adc24a0_303" data-sync-tabs="java"  data-title="Java" ><div class="code-block" data-lang="java"    data-title="Java"     >
UastFacade.INSTANCE.convertElementWithParent(element,
    new Class[]{UInjectionHost.class, UReferenceExpression.class});
</div></div><div class="tabs__content" data-gtm="tab" id="5adc24a0_305" data-sync-tabs="kotlin"  data-title="Kotlin" ><div class="code-block" data-lang="kotlin"    data-title="Kotlin"     >
UastFacade.convertElementWithParent(element,
    UInjectionHost::class.java, UReferenceExpression::class.java)
</div></div></div></li><li class="list__item" id="5adc24a0_307" ><p id="5adc24a0_308" >in some cases, <code class="code " id="5adc24a0_309"  >PsiElement</code> could represent several <code class="code " id="5adc24a0_310"  >UElement</code>s. For instance, the parameter of a primary constructor in Kotlin is <code class="code " id="5adc24a0_311"  >UField</code> and <code class="code " id="5adc24a0_312"  >UParameter</code> at the same time. When needing all options, use:</p><div class="tabs" id="5adc24a0_313"data-group="languages"><div class="tabs__content" data-gtm="tab" id="5adc24a0_314" data-sync-tabs="java"  data-title="Java" ><div class="code-block" data-lang="java"    data-title="Java"     >
UastFacade.INSTANCE.convertToAlternatives(element,
    new Class[]{UField.class, UParameter.class});
</div></div><div class="tabs__content" data-gtm="tab" id="5adc24a0_316" data-sync-tabs="kotlin"  data-title="Kotlin" ><div class="code-block" data-lang="kotlin"    data-title="Kotlin"     >
UastFacade.convertToAlternatives(element,
    UField::class.java, UParameter::class.java)
</div></div></div></li></ul><aside data-type="tip" class="prompt" data-title="" id="5adc24a0_318" ><p id="5adc24a0_319" >It is always better to convert to the specific type of <code class="code " id="5adc24a0_320"  >UElement</code>, rather than to convert without type and then cast to the specific type:</p><ul class="list _ul" id="5adc24a0_321"    ><li class="list__item" id="5adc24a0_322" ><p>Because of performance: <code class="code " id="5adc24a0_323"  >toUElement()</code> with type is fail-fast</p></li><li class="list__item" id="5adc24a0_324" ><p>Because of possibly getting different results in some cases: conversion with type is more predictable</p></li></ul></aside></section><section class="chapter"  ><h3 id="uast-to-psi-conversion" data-toc="uast-to-psi-conversion"  >UAST to PSI Conversion</h3><p id="5adc24a0_325" >Sometimes it's required to get from the <code class="code " id="5adc24a0_326"  >UElement</code> back to sources of the underlying language. For that purpose, <code class="code " id="5adc24a0_327"  >UElement#sourcePsi</code> property returns the corresponding <code class="code " id="5adc24a0_328"  >PsiElement</code> of the original language.</p><p id="5adc24a0_329" >The <code class="code " id="5adc24a0_330"  >sourcePsi</code> is a &quot;physical&quot; <code class="code " id="5adc24a0_331"  >PsiElement</code>, and it is mostly used for getting text ranges in the original file (e.g., for highlighting). Avoid casting the <code class="code " id="5adc24a0_332"  >sourcePsi</code> to specific classes because it means falling back from the UAST abstraction to the language-specific PSI. Some <code class="code " id="5adc24a0_333"  >UElement</code> are &quot;virtual&quot; and thus do not have <code class="code " id="5adc24a0_334"  >sourcePsi</code>. For some <code class="code " id="5adc24a0_335"  >UElement</code>, the <code class="code " id="5adc24a0_336"  >sourcePsi</code> could be different from the element from which the <code class="code " id="5adc24a0_337"  >UElement</code> was obtained.</p><p id="5adc24a0_338" >Also, there is a <code class="code " id="5adc24a0_339"  >UElement#javaPsi</code> property that returns a &quot;Java-like&quot; <code class="code " id="5adc24a0_340"  >PsiElement</code>. It is a &quot;fake&quot; <code class="code " id="5adc24a0_341"  >PsiElement</code> to make different JVM languages emulate Java language to keep compatibility with Java-API. For instance, when calling <code class="code " id="5adc24a0_342"  >MethodReferencesSearch.search(PsiMethod)</code>, only Java natively provides <code class="code " id="5adc24a0_343"  >PsiMethod</code>; other JVM languages thus provide a &quot;fake&quot; <code class="code " id="5adc24a0_344"  >PsiMethod</code> via <code class="code " id="5adc24a0_345"  >UMethod#javaPsi</code>.</p><p id="5adc24a0_346" >Note that <code class="code " id="5adc24a0_347"  >UElement#javaPsi</code> is physical for Java only. Thus <code class="code " id="5adc24a0_348"  >UElement#sourcePsi</code> should be used to obtain text-range or an anchor element for inspection warnings/gutter marker placement.</p><p id="5adc24a0_349" >In short:</p><p id="5adc24a0_350" ><code class="code " id="5adc24a0_351"  >sourcePsi</code>:</p><ul class="list _ul" id="5adc24a0_352"    ><li class="list__item" id="5adc24a0_353" ><p>is physical: represents a real existing <code class="code " id="5adc24a0_354"  >PsiElement</code> in the sources of the original language</p></li><li class="list__item" id="5adc24a0_355" ><p>can be used for highlighting, PSI modifications, creating smart-pointers, etc.</p></li><li class="list__item" id="5adc24a0_356" ><p>should not be cast unless absolutely required (for instance, handling a language-specific case)</p></li></ul><p id="5adc24a0_357" ><code class="code " id="5adc24a0_358"  >javaPsi</code>:</p><ul class="list _ul" id="5adc24a0_359"    ><li class="list__item" id="5adc24a0_360" ><p>should be used only as a representation of JVM-visible declarations: <code class="code " id="5adc24a0_361"  >PsiClass</code>, <code class="code " id="5adc24a0_362"  >PsiMethod</code>, <code class="code " id="5adc24a0_363"  >PsiField</code> for getting their names, types, parameters, etc., or to pass them to methods that accept Java-PSI declarations</p></li><li class="list__item" id="5adc24a0_364" ><p>not guaranteed to be physical: could not exist in sources</p></li><li class="list__item" id="5adc24a0_365" ><p>is not modifiable: calling modification methods could throw exceptions for non-Java languages</p></li></ul><p id="5adc24a0_366" >Note: both <code class="code " id="5adc24a0_367"  >sourcePsi</code> and <code class="code " id="5adc24a0_368"  >javaPsi</code> can be <a href="#psi-to-uast-conversion" id="5adc24a0_369" data-tooltip="To obtain UAST for given PsiElement of one of supported languages, use UastFacade class or UastContextKt.toUElement():"  >converted</a> back to the <code class="code " id="5adc24a0_370"  >UElement</code>.</p></section></section><section class="chapter"  ><h2 id="uast-visitors" data-toc="uast-visitors"  >UAST Visitors</h2><p id="5adc24a0_371" >In UAST there is no unified way to get <span class="emphasis" id="5adc24a0_372" >children</span> of the <code class="code " id="5adc24a0_373"  >UElement</code> (though it is possible to get its parent via <code class="code " id="5adc24a0_374"  >UElement#uastParent</code>). Thus, the only way to walk the UAST as a tree is passing the <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/uast/uast-common/src/org/jetbrains/uast/visitor/UastVisitor.kt" id="5adc24a0_375"   data-external="true" rel="noopener noreferrer" ><code class="code " id="5adc24a0_376"  >UastVisitor</code></a> to <code class="code " id="5adc24a0_377"  >UElement.accept()</code> method.</p><p id="5adc24a0_378" >Note: there is a convention in UAST-visitors that a visitor will not be passed to children if <code class="code " id="5adc24a0_379"  >visit*()</code> returns <code class="code " id="5adc24a0_380"  >true</code>. Otherwise, <code class="code " id="5adc24a0_381"  >UastVisitor</code> will continue the walk into depth.</p><p id="5adc24a0_382" ><code class="code " id="5adc24a0_383"  >UastVisitor</code> can be converted to <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/platform/core-api/src/com/intellij/psi/PsiElementVisitor.java" id="5adc24a0_384"   data-external="true" rel="noopener noreferrer" ><code class="code " id="5adc24a0_385"  >PsiElementVisitor</code></a> using <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/java/java-analysis-api/src/com/intellij/uast/UastVisitorAdapter.java" id="5adc24a0_386"   data-external="true" rel="noopener noreferrer" ><code class="code " id="5adc24a0_387"  >UastVisitorAdapter</code></a> or <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/java/java-analysis-api/src/com/intellij/uast/UastHintedVisitorAdapter.kt" id="5adc24a0_388"   data-external="true" rel="noopener noreferrer" ><code class="code " id="5adc24a0_389"  >UastHintedVisitorAdapter</code></a>. The latter is preferable as it offers better performance and more predictable results.</p><p id="5adc24a0_390" >As a general rule, it's recommended to abstain from using <code class="code " id="5adc24a0_391"  >UastVisitor</code>: if you don't need to process many <code class="code " id="5adc24a0_392"  >UElement</code>s of different types and if the structure of elements is not very important, then it is better to walk the PSI-tree using <code class="code " id="5adc24a0_393"  >PsiElementVisitor</code> and <a href="#psi-to-uast-conversion" id="5adc24a0_394" data-tooltip="To obtain UAST for given PsiElement of one of supported languages, use UastFacade class or UastContextKt.toUElement():"  >convert</a> each <code class="code " id="5adc24a0_395"  >PsiElement</code> to its corresponding UAST explicitly via <code class="code " id="5adc24a0_396"  >UastContext.toUElement()</code>.</p></section><section class="chapter"  ><h2 id="uast-performance-hints" data-toc="uast-performance-hints"  >UAST Performance Hints</h2><p id="5adc24a0_397" >UAST is not a zero-cost abstraction: <a href="https://youtrack.jetbrains.com/issue/KT-29856" id="5adc24a0_398"   data-external="true" rel="noopener noreferrer" >some methods</a> could be unexpectedly expensive for some languages, so be careful with optimizations because it could yield the opposite effect.</p><p id="5adc24a0_399" ><a href="#psi-to-uast-conversion" id="5adc24a0_400" data-tooltip="To obtain UAST for given PsiElement of one of supported languages, use UastFacade class or UastContextKt.toUElement():"  >Converting</a> to <code class="code " id="5adc24a0_401"  >UElement</code> also could require resolve for some languages in some cases, again, possibly unexpectedly expensive. Converting to UAST should be performed only when necessary. For instance, converting the whole <code class="code " id="5adc24a0_402"  >PsiFile</code> to <code class="code " id="5adc24a0_403"  >UFile</code> and then walk it solely to collect <code class="code " id="5adc24a0_404"  >UMethod</code> declarations is inefficient. Instead, walk the <code class="code " id="5adc24a0_405"  >PsiFile</code> and convert each encountered matching element to <code class="code " id="5adc24a0_406"  >UMethod</code> explicitly.</p><p id="5adc24a0_407" >UAST is lazy when you pass visitors to <code class="code " id="5adc24a0_408"  >UElement.accept()</code> or getting <code class="code " id="5adc24a0_409"  >UElement#uastParent</code>.</p><p id="5adc24a0_410" >For really hard performance optimisation consider using <code class="code " id="5adc24a0_411"  >UastLanguagePlugin.getPossiblePsiSourceTypes()</code> to pre-filter <code class="code " id="5adc24a0_412"  >PsiElement</code>s before converting them to UAST.</p></section><section class="chapter"  ><h2 id="uast-caveats" data-toc="uast-caveats"  >UAST Caveats</h2><section class="chapter"  ><h3 id="uliteralexpression-should-not-be-used-for-strings" data-toc="uliteralexpression-should-not-be-used-for-strings"  >ULiteralExpression should not be used for strings</h3><p id="5adc24a0_413" ><a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/uast/uast-common/src/org/jetbrains/uast/expressions/ULiteralExpression.kt" id="5adc24a0_414"   data-external="true" rel="noopener noreferrer" ><code class="code " id="5adc24a0_415"  >ULiteralExpression</code></a> represents literal values like numbers, booleans, and string. Although string values are also literals, <code class="code " id="5adc24a0_416"  >ULiteralExpression</code> is not very handy to work with them. For instance, it doesn't handle Kotlin's string interpolations. To process string literals when evaluating their value or to perform language injection, use <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/uast/uast-common/src/org/jetbrains/uast/expressions/UInjectionHost.kt" id="5adc24a0_417"   data-external="true" rel="noopener noreferrer" ><code class="code " id="5adc24a0_418"  >UInjectionHost</code></a> instead.</p></section><section class="chapter"  ><h3 id="sourcepsi-and-javapsi-psi-and-uelement-as-psi" data-toc="sourcepsi-and-javapsi-psi-and-uelement-as-psi"  >sourcePsi and javaPsi, psi and UElement as PSI</h3><p id="5adc24a0_419" >For historical reasons, the relations between <code class="code " id="5adc24a0_420"  >UElement</code> and <code class="code " id="5adc24a0_421"  >PsiElement</code> are complicated. Some <code class="code " id="5adc24a0_422"  >UElement</code>s implement <code class="code " id="5adc24a0_423"  >PsiElement</code>; for instance, <code class="code " id="5adc24a0_424"  >UMethod</code> implements <code class="code " id="5adc24a0_425"  >PsiMethod</code>. It is strongly discouraged to use <code class="code " id="5adc24a0_426"  >UElement</code> as <code class="code " id="5adc24a0_427"  >PsiElement</code>, and Plugin DevKit provides a corresponding inspection (<span class="control" id="5adc24a0_428" >Plugin DevKit | Code | UElement as PsiElement usage</span>). This <span class="emphasis" id="5adc24a0_429" >&quot;implements&quot;</span> is considered deprecated and might be removed in the future.</p><p id="5adc24a0_430" >Also, there is <code class="code " id="5adc24a0_431"  >UElement#psi</code> property; it returns the same element as <code class="code " id="5adc24a0_432"  >javaPsi</code> or the <code class="code " id="5adc24a0_433"  >sourcePsi</code>. As it is hard to guess what will be returned, it is also deprecated.</p><p id="5adc24a0_434" >Thus <code class="code " id="5adc24a0_435"  >sourcePsi</code> and <code class="code " id="5adc24a0_436"  >javaPsi</code> should be the only ways to obtain <code class="code " id="5adc24a0_437"  >PsiElement</code> from <code class="code " id="5adc24a0_438"  >UElement</code>. See the <a href="#uast-to-psi-conversion" id="5adc24a0_439" data-tooltip="Sometimes it's required to get from the UElement back to sources of the underlying language. For that purpose, UElement#sourcePsi property returns the corresponding PsiElement of the original language."  >corresponding section</a>.</p></section><section class="chapter"  ><h3 id="should-i-use-umethod-or-psimethod-uclass-or-psiclass" data-toc="should-i-use-umethod-or-psimethod-uclass-or-psiclass"  >Should I use UMethod or PsiMethod, UClass or PsiClass ?</h3><p id="5adc24a0_440" >UAST provides a unified way to represent JVM compatible declarations via <code class="code " id="5adc24a0_441"  >UMethod</code>, <code class="code " id="5adc24a0_442"  >UField</code>, <code class="code " id="5adc24a0_443"  >UClass</code>, and so on. But at the same time, all JVM language plugins implement <code class="code " id="5adc24a0_444"  >PsiMethod</code>, <code class="code " id="5adc24a0_445"  >PsiClass</code>, and so on to be compatible with Java. These implementations could be <a href="#uast-to-psi-conversion" id="5adc24a0_446" data-tooltip="Sometimes it's required to get from the UElement back to sources of the underlying language. For that purpose, UElement#sourcePsi property returns the corresponding PsiElement of the original language."  >obtained</a> via <code class="code " id="5adc24a0_447"  >UElement#javaPsi</code> property.</p><p id="5adc24a0_448" >So the question is: &quot;What should I use to represent the Java-declaration in my code?&quot;. The answer is: We encourage using <code class="code " id="5adc24a0_449"  >PsiMethod</code>, <code class="code " id="5adc24a0_450"  >PsiClass</code> as common interfaces for Java-declarations regardless of the JVM language and discourage exposing the UAST interfaces in the API.</p><p id="5adc24a0_451" >Note: for method bodies, there are no such alternatives, so exposing, for instance, the <code class="code " id="5adc24a0_452"  >UExpression</code> is not discouraged. Still, consider exposing the raw <code class="code " id="5adc24a0_453"  >PsiElement</code> instead.</p></section><section class="chapter"  ><h3 id="uastpsi-tree-structure-mismatch" data-toc="uastpsi-tree-structure-mismatch"  >UAST/PSI Tree Structure Mismatch</h3><p id="5adc24a0_454" >UAST is an abstraction level on top of PSI of different languages and tries to build a unified tree (see <a href="#inspecting-uast-tree" id="5adc24a0_455" data-tooltip="To inspect UAST Tree, invoke internal action Tools | Internal Actions | UAST | Dump UAST Tree (By Each PsiElement)."  >Inspecting UAST Tree</a>). It leads to the fact that the tree structure could seriously diverge between UAST and original language, so no ancestor-descendant relation preserving is guaranteed.</p><p id="5adc24a0_456" >For instance, the results of:</p><div class="code-block" data-lang="kotlin"         >
generateSequence(uElement, UElement::uastParent).mapNotNull { it.sourcePsi }
generateSequence(uElement.sourcePsi) { it.parent }
</div><p id="5adc24a0_458" >could be different, not only in the number of elements, but also in their order.</p></section></section><section class="chapter"  ><h2 id="using-uast-in-plugins" data-toc="using-uast-in-plugins"  >Using UAST in Plugins</h2><p id="5adc24a0_459" >To register extensions applicable to UAST, specify <code class="code " id="5adc24a0_460"  >language=&quot;UAST&quot;</code> in <span class="filepath" id="5adc24a0_461" ><a href="plugin-configuration-file.html" id="5adc24a0_462" data-tooltip="Plugin configuration file contains all the information about the plugin, as well as all registered extensions, actions, listeners, etc."  >plugin.xml</a></span>.</p><section class="chapter"  ><h3 id="inspecting-uast-tree" data-toc="inspecting-uast-tree"  >Inspecting UAST Tree</h3><p id="5adc24a0_463" >To inspect UAST Tree, invoke <a href="enabling-internal.html" id="5adc24a0_464" data-tooltip="某些工具例如内部操作菜单, 只有在IntelliJ IDEA的内部模式启用时才能看到."  >internal action</a>.</p></section><section class="chapter"  ><h3 id="inspections" data-toc="inspections"  >Inspections</h3><p id="5adc24a0_466" >Use <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/java/java-analysis-api/src/com/intellij/codeInspection/AbstractBaseUastLocalInspectionTool.java" id="5adc24a0_467"   data-external="true" rel="noopener noreferrer" ><code class="code " id="5adc24a0_468"  >AbstractBaseUastLocalInspectionTool</code></a> as base class and specify <code class="code " id="5adc24a0_469"  >language=&quot;UAST&quot;</code> in registration. If inspection targets only a subset of default types (<code class="code " id="5adc24a0_470"  >UFile</code>, <code class="code " id="5adc24a0_471"  >UClass</code>, <code class="code " id="5adc24a0_472"  >UField</code>, and <code class="code " id="5adc24a0_473"  >UMethod</code>), specify <code class="code " id="5adc24a0_474"  >UElement</code>s as hints in overloaded constructor to improve performance.</p></section><section class="chapter"  ><h3 id="line-marker" data-toc="line-marker"  >Line Marker</h3><p id="5adc24a0_475" >Use <code class="code " id="5adc24a0_476"  >UastUtils.getUParentForIdentifier()</code> or <code class="code " id="5adc24a0_477"  >UAnnotationUtils.getIdentifierAnnotationOwner()</code> for annotations to obtain suitable &quot;identifier&quot; element (see <a href="line-marker-provider.html" id="5adc24a0_478" data-tooltip="Code: SimpleLineMarkerProvider"  >Line Marker Provider</a> for details).</p></section></section><div class="last-modified"> Last modified: 29 九月 2022</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="element-patterns.html">Element Patterns</a>   <a class="navigation-links__next" href="xml-dom-api.html">XML DOM API</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/storage/help-app/v5/app.js"></script></body></html>
<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8">  <meta name="built-on" content="2022-09-28T11:33:50.2554055"><meta name="build-number" content="${buildNumber}">    <meta name="keywords" content="">  <title>UAST - Unified Abstract Syntax Tree | IntelliJ Platform Plugin SDK</title><script id="virtual-toc-data" type="application/json">[{"id":"motivation","level":0,"title":"Motivation","anchor":"#motivation"},{"id":"working-with-uast","level":0,"title":"Working with UAST","anchor":"#working-with-uast"},{"id":"uast-visitors","level":0,"title":"UAST Visitors","anchor":"#uast-visitors"},{"id":"uast-performance-hints","level":0,"title":"UAST Performance Hints","anchor":"#uast-performance-hints"},{"id":"uast-caveats","level":0,"title":"UAST Caveats","anchor":"#uast-caveats"},{"id":"using-uast-in-plugins","level":0,"title":"Using UAST in Plugins","anchor":"#using-uast-in-plugins"}]</script>   <link href="https://resources.jetbrains.com/storage/help-app/v5/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content="https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png"><!-- Open Graph --><meta property="og:title" content="UAST - Unified Abstract Syntax Tree | IntelliJ Platform Plugin SDK"/><meta property="og:description" content=""/><meta property="og:image" content="https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png"/><meta property="og:site_name" content="IntelliJ Platform Plugin SDK Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="https://plugins.jetbrains.com/docs/intellij/uast.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@JBPlatform"><meta name="twitter:title" content="UAST - Unified Abstract Syntax Tree | IntelliJ Platform Plugin SDK"><meta name="twitter:description" content=""><meta name="twitter:creator" content="@JBPlatform"><meta name="twitter:image:src" content="https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png"><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "https://plugins.jetbrains.com/docs/intellij/uast.html#webpage", "url": "https://plugins.jetbrains.com/docs/intellij/uast.html", "name": "UAST - Unified Abstract Syntax Tree | IntelliJ Platform Plugin SDK", "description": "", "image": "https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "https://plugins.jetbrains.com/docs/intellij/#website", "url": "https://plugins.jetbrains.com/docs/intellij/", "name": "IntelliJ Platform Plugin SDK Help" }</script><!-- End Schema.org --></head>    <body data-id="uast.md" data-main-title="UAST - Unified Abstract Syntax Tree" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="Part IV — PSI"  data-edit-url="https://github.com/JetBrains/intellij-sdk-docs/edit/main/topics/basics/architectural_overview/uast.md"  >  <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>IntelliJ Platform Plugin SDK  Help</h3><div class="shortcuts-switcher"><label for="switch-shortcuts">Keymap:</label><select class="select _shortcuts" height="1" id="switch-shortcuts">      </select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="uast.md" id="uast.md"  >UAST - Unified Abstract Syntax Tree</h1><p id="b751122d_1" >UAST (Unified Abstract Syntax Tree) is an abstraction layer on the <a href="psi-elements.html" id="b751122d_2" data-tooltip="A PSI (Program Structure Interface) file represents a hierarchy of PSI elements (so-called PSI trees). A single PSI file (itself being a PSI element) may expose several PSI trees in specific programming languages (see ). A PSI element, in its turn, can have child PSI elements."  >PSI</a> of different JVM languages. It provides a unified API for working with common language elements like classes and method declarations, literal values, and control flow operators.</p><section class="chapter"  ><h2 id="motivation" data-toc="motivation"  >Motivation</h2><p id="b751122d_3" >Different JVM languages have their own <a href="psi-elements.html" id="b751122d_4" data-tooltip="A PSI (Program Structure Interface) file represents a hierarchy of PSI elements (so-called PSI trees). A single PSI file (itself being a PSI element) may expose several PSI trees in specific programming languages (see ). A PSI element, in its turn, can have child PSI elements."  >PSI</a>, but many IDE features like inspections, gutter markers, reference injection, and many others work the same way for all these languages.</p><p id="b751122d_5" >Using UAST allows providing features that will work across all <a href="#which-languages-are-supported" id="b751122d_6" data-tooltip="Java: full support Kotlin: full support Scala: beta, but full support Groovy: declarations only, method bodies not supported"  >supported JVM languages</a> using a single implementation.</p><p id="b751122d_7" >Presentation <a href="https://www.youtube.com/watch?v=j2tvi4GbOr4" id="b751122d_8"   data-external="true" rel="noopener noreferrer" >Writing IntelliJ Plugins for Kotlin</a> offers a thorough overview of using UAST in real-world scenarios.</p><section class="chapter"  ><h3 id="when-should-i-use-uast" data-toc="when-should-i-use-uast"  >When should I use UAST?</h3><p id="b751122d_9" >For plugins, that should work for all JVM languages in the same way.</p><p id="b751122d_10" >Some known examples are:</p><ul class="list _ul" id="b751122d_11"    ><li class="list__item" id="b751122d_12" ><p><a href="spring-api.html" id="b751122d_13" data-tooltip="Spring API allows 3rd party plugins to re-use, integrate with or extend existing Spring Framework support in IntelliJ IDEA Ultimate."  >Spring Framework</a></p></li><li class="list__item" id="b751122d_14" ><p><a href="android-studio.html" id="b751122d_15" data-tooltip="Android Studio plugins extend or add functionality to the Android Studio IDE. Plugins can be written in Kotlin or Java, or a mix of both, and are created using IntelliJ IDEA and the IntelliJ Platform. It's also helpful to be familiar with Java Swing. Once completed, plugins can be…"  >Android Studio</a></p></li><li class="list__item" id="b751122d_16" ><p><a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/plugins/devkit/devkit-core" id="b751122d_17"   data-external="true" rel="noopener noreferrer" >Plugin DevKit</a></p></li></ul></section><section class="chapter"  ><h3 id="which-languages-are-supported" data-toc="which-languages-are-supported"  >Which languages are supported?</h3><ul class="list _ul" id="b751122d_18"    ><li class="list__item" id="b751122d_19" ><p>Java: full support</p></li><li class="list__item" id="b751122d_20" ><p>Kotlin: full support</p></li><li class="list__item" id="b751122d_21" ><p>Scala: beta, but full support</p></li><li class="list__item" id="b751122d_22" ><p>Groovy: declarations only, method bodies not supported</p></li></ul></section><section class="chapter"  ><h3 id="what-about-modifying-psi" data-toc="what-about-modifying-psi"  >What about modifying PSI?</h3><p id="b751122d_23" >UAST is a read-only API. There are experimental <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/uast/uast-common/src/org/jetbrains/uast/generate/UastCodeGenerationPlugin.kt" id="b751122d_24"   data-external="true" rel="noopener noreferrer" ><code class="code " id="b751122d_25"  >UastCodeGenerationPlugin</code></a> and <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/java/java-analysis-api/src/com/intellij/lang/jvm/actions/JvmElementActionsFactory.kt" id="b751122d_26"   data-external="true" rel="noopener noreferrer" ><code class="code " id="b751122d_27"  >JvmElementActionsFactory</code></a> classes, but they are currently not recommended for external usage.</p></section></section><section class="chapter"  ><h2 id="working-with-uast" data-toc="working-with-uast"  >Working with UAST</h2><p id="b751122d_28" >The base element of UAST is <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/uast/uast-common/src/org/jetbrains/uast/baseElements/UElement.kt" id="b751122d_29"   data-external="true" rel="noopener noreferrer" ><code class="code " id="b751122d_30"  >UElement</code></a>. All common base sub-interfaces are located in the <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/uast/uast-common/src/org/jetbrains/uast/declarations" id="b751122d_31"   data-external="true" rel="noopener noreferrer" >declarations</a> and <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/uast/uast-common/src/org/jetbrains/uast/expressions" id="b751122d_32"   data-external="true" rel="noopener noreferrer" >expressions</a> directories of the <span class="control" id="b751122d_33" >uast</span> module.</p><p id="b751122d_34" >All these sub-interfaces provide methods to get the information about common syntax elements: <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/uast/uast-common/src/org/jetbrains/uast/declarations/UClass.kt" id="b751122d_35"   data-external="true" rel="noopener noreferrer" ><code class="code " id="b751122d_36"  >UClass</code></a> about class declarations, <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/uast/uast-common/src/org/jetbrains/uast/controlStructures/UIfExpression.kt" id="b751122d_37"   data-external="true" rel="noopener noreferrer" ><code class="code " id="b751122d_38"  >UIfExpression</code></a> about conditional expressions, and so on.</p><section class="chapter"  ><h3 id="psi-to-uast-conversion" data-toc="psi-to-uast-conversion"  >PSI to UAST Conversion</h3><p id="b751122d_39" >To obtain UAST for given <code class="code " id="b751122d_40"  >PsiElement</code> of one of supported languages, use <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/uast/uast-common/src/org/jetbrains/uast/UastContext.kt" id="b751122d_41"   data-external="true" rel="noopener noreferrer" ><code class="code " id="b751122d_42"  >UastFacade</code></a> class or <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/uast/uast-common/src/org/jetbrains/uast/UastContext.kt" id="b751122d_43"   data-external="true" rel="noopener noreferrer" ><code class="code " id="b751122d_44"  >UastContextKt.toUElement()</code></a>:</p><div class="tabs" id="b751122d_45"data-group="languages"><div class="tabs__content" data-gtm="tab" id="b751122d_46" data-sync-tabs="java"  data-title="Java" ><div class="code-block" data-lang="java"    data-title="Java"     >
UastContextKt.toUElement(element);
</div></div><div class="tabs__content" data-gtm="tab" id="b751122d_48" data-sync-tabs="kotlin"  data-title="Kotlin" ><div class="code-block" data-lang="kotlin"    data-title="Kotlin"     >
element.toUElement()
</div></div></div><p id="b751122d_50" >To convert <code class="code " id="b751122d_51"  >PsiElement</code> to the specific <code class="code " id="b751122d_52"  >UElement</code>, use one of the following approaches:</p><ul class="list _ul" id="b751122d_53"    ><li class="list__item" id="b751122d_54" ><p id="b751122d_55" >for simple conversion:</p><div class="tabs" id="b751122d_56"data-group="languages"><div class="tabs__content" data-gtm="tab" id="b751122d_57" data-sync-tabs="java"  data-title="Java" ><div class="code-block" data-lang="java"    data-title="Java"     >
UastContextKt.toUElement(element, UCallExpression.class);
</div></div><div class="tabs__content" data-gtm="tab" id="b751122d_59" data-sync-tabs="kotlin"  data-title="Kotlin" ><div class="code-block" data-lang="kotlin"    data-title="Kotlin"     >
element.toUElement(UCallExpression::class.java)
</div></div></div></li><li class="list__item" id="b751122d_61" ><p id="b751122d_62" >for conversion to one of different given options:</p><div class="tabs" id="b751122d_63"data-group="languages"><div class="tabs__content" data-gtm="tab" id="b751122d_64" data-sync-tabs="java"  data-title="Java" ><div class="code-block" data-lang="java"    data-title="Java"     >
UastFacade.INSTANCE.convertElementWithParent(element,
    new Class[]{UInjectionHost.class, UReferenceExpression.class});
</div></div><div class="tabs__content" data-gtm="tab" id="b751122d_66" data-sync-tabs="kotlin"  data-title="Kotlin" ><div class="code-block" data-lang="kotlin"    data-title="Kotlin"     >
UastFacade.convertElementWithParent(element,
    UInjectionHost::class.java, UReferenceExpression::class.java)
</div></div></div></li><li class="list__item" id="b751122d_68" ><p id="b751122d_69" >in some cases, <code class="code " id="b751122d_70"  >PsiElement</code> could represent several <code class="code " id="b751122d_71"  >UElement</code>s. For instance, the parameter of a primary constructor in Kotlin is <code class="code " id="b751122d_72"  >UField</code> and <code class="code " id="b751122d_73"  >UParameter</code> at the same time. When needing all options, use:</p><div class="tabs" id="b751122d_74"data-group="languages"><div class="tabs__content" data-gtm="tab" id="b751122d_75" data-sync-tabs="java"  data-title="Java" ><div class="code-block" data-lang="java"    data-title="Java"     >
UastFacade.INSTANCE.convertToAlternatives(element,
    new Class[]{UField.class, UParameter.class});
</div></div><div class="tabs__content" data-gtm="tab" id="b751122d_77" data-sync-tabs="kotlin"  data-title="Kotlin" ><div class="code-block" data-lang="kotlin"    data-title="Kotlin"     >
UastFacade.convertToAlternatives(element,
    UField::class.java, UParameter::class.java)
</div></div></div></li></ul><aside data-type="tip" class="prompt" data-title="" id="b751122d_79" ><p id="b751122d_80" >It is always better to convert to the specific type of <code class="code " id="b751122d_81"  >UElement</code>, rather than to convert without type and then cast to the specific type:</p><ul class="list _ul" id="b751122d_82"    ><li class="list__item" id="b751122d_83" ><p>Because of performance: <code class="code " id="b751122d_84"  >toUElement()</code> with type is fail-fast</p></li><li class="list__item" id="b751122d_85" ><p>Because of possibly getting different results in some cases: conversion with type is more predictable</p></li></ul></aside></section><section class="chapter"  ><h3 id="uast-to-psi-conversion" data-toc="uast-to-psi-conversion"  >UAST to PSI Conversion</h3><p id="b751122d_86" >Sometimes it's required to get from the <code class="code " id="b751122d_87"  >UElement</code> back to sources of the underlying language. For that purpose, <code class="code " id="b751122d_88"  >UElement#sourcePsi</code> property returns the corresponding <code class="code " id="b751122d_89"  >PsiElement</code> of the original language.</p><p id="b751122d_90" >The <code class="code " id="b751122d_91"  >sourcePsi</code> is a &quot;physical&quot; <code class="code " id="b751122d_92"  >PsiElement</code>, and it is mostly used for getting text ranges in the original file (e.g., for highlighting). Avoid casting the <code class="code " id="b751122d_93"  >sourcePsi</code> to specific classes because it means falling back from the UAST abstraction to the language-specific PSI. Some <code class="code " id="b751122d_94"  >UElement</code> are &quot;virtual&quot; and thus do not have <code class="code " id="b751122d_95"  >sourcePsi</code>. For some <code class="code " id="b751122d_96"  >UElement</code>, the <code class="code " id="b751122d_97"  >sourcePsi</code> could be different from the element from which the <code class="code " id="b751122d_98"  >UElement</code> was obtained.</p><p id="b751122d_99" >Also, there is a <code class="code " id="b751122d_100"  >UElement#javaPsi</code> property that returns a &quot;Java-like&quot; <code class="code " id="b751122d_101"  >PsiElement</code>. It is a &quot;fake&quot; <code class="code " id="b751122d_102"  >PsiElement</code> to make different JVM languages emulate Java language to keep compatibility with Java-API. For instance, when calling <code class="code " id="b751122d_103"  >MethodReferencesSearch.search(PsiMethod)</code>, only Java natively provides <code class="code " id="b751122d_104"  >PsiMethod</code>; other JVM languages thus provide a &quot;fake&quot; <code class="code " id="b751122d_105"  >PsiMethod</code> via <code class="code " id="b751122d_106"  >UMethod#javaPsi</code>.</p><p id="b751122d_107" >Note that <code class="code " id="b751122d_108"  >UElement#javaPsi</code> is physical for Java only. Thus <code class="code " id="b751122d_109"  >UElement#sourcePsi</code> should be used to obtain text-range or an anchor element for inspection warnings/gutter marker placement.</p><p id="b751122d_110" >In short:</p><p id="b751122d_111" ><code class="code " id="b751122d_112"  >sourcePsi</code>:</p><ul class="list _ul" id="b751122d_113"    ><li class="list__item" id="b751122d_114" ><p>is physical: represents a real existing <code class="code " id="b751122d_115"  >PsiElement</code> in the sources of the original language</p></li><li class="list__item" id="b751122d_116" ><p>can be used for highlighting, PSI modifications, creating smart-pointers, etc.</p></li><li class="list__item" id="b751122d_117" ><p>should not be cast unless absolutely required (for instance, handling a language-specific case)</p></li></ul><p id="b751122d_118" ><code class="code " id="b751122d_119"  >javaPsi</code>:</p><ul class="list _ul" id="b751122d_120"    ><li class="list__item" id="b751122d_121" ><p>should be used only as a representation of JVM-visible declarations: <code class="code " id="b751122d_122"  >PsiClass</code>, <code class="code " id="b751122d_123"  >PsiMethod</code>, <code class="code " id="b751122d_124"  >PsiField</code> for getting their names, types, parameters, etc., or to pass them to methods that accept Java-PSI declarations</p></li><li class="list__item" id="b751122d_125" ><p>not guaranteed to be physical: could not exist in sources</p></li><li class="list__item" id="b751122d_126" ><p>is not modifiable: calling modification methods could throw exceptions for non-Java languages</p></li></ul><p id="b751122d_127" >Note: both <code class="code " id="b751122d_128"  >sourcePsi</code> and <code class="code " id="b751122d_129"  >javaPsi</code> can be <a href="#psi-to-uast-conversion" id="b751122d_130" data-tooltip="To obtain UAST for given PsiElement of one of supported languages, use UastFacade class or UastContextKt.toUElement():"  >converted</a> back to the <code class="code " id="b751122d_131"  >UElement</code>.</p></section></section><section class="chapter"  ><h2 id="uast-visitors" data-toc="uast-visitors"  >UAST Visitors</h2><p id="b751122d_132" >In UAST there is no unified way to get <span class="emphasis" id="b751122d_133" >children</span> of the <code class="code " id="b751122d_134"  >UElement</code> (though it is possible to get its parent via <code class="code " id="b751122d_135"  >UElement#uastParent</code>). Thus, the only way to walk the UAST as a tree is passing the <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/uast/uast-common/src/org/jetbrains/uast/visitor/UastVisitor.kt" id="b751122d_136"   data-external="true" rel="noopener noreferrer" ><code class="code " id="b751122d_137"  >UastVisitor</code></a> to <code class="code " id="b751122d_138"  >UElement.accept()</code> method.</p><p id="b751122d_139" >Note: there is a convention in UAST-visitors that a visitor will not be passed to children if <code class="code " id="b751122d_140"  >visit*()</code> returns <code class="code " id="b751122d_141"  >true</code>. Otherwise, <code class="code " id="b751122d_142"  >UastVisitor</code> will continue the walk into depth.</p><p id="b751122d_143" ><code class="code " id="b751122d_144"  >UastVisitor</code> can be converted to <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/platform/core-api/src/com/intellij/psi/PsiElementVisitor.java" id="b751122d_145"   data-external="true" rel="noopener noreferrer" ><code class="code " id="b751122d_146"  >PsiElementVisitor</code></a> using <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/java/java-analysis-api/src/com/intellij/uast/UastVisitorAdapter.java" id="b751122d_147"   data-external="true" rel="noopener noreferrer" ><code class="code " id="b751122d_148"  >UastVisitorAdapter</code></a> or <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/java/java-analysis-api/src/com/intellij/uast/UastHintedVisitorAdapter.kt" id="b751122d_149"   data-external="true" rel="noopener noreferrer" ><code class="code " id="b751122d_150"  >UastHintedVisitorAdapter</code></a>. The latter is preferable as it offers better performance and more predictable results.</p><p id="b751122d_151" >As a general rule, it's recommended to abstain from using <code class="code " id="b751122d_152"  >UastVisitor</code>: if you don't need to process many <code class="code " id="b751122d_153"  >UElement</code>s of different types and if the structure of elements is not very important, then it is better to walk the PSI-tree using <code class="code " id="b751122d_154"  >PsiElementVisitor</code> and <a href="#psi-to-uast-conversion" id="b751122d_155" data-tooltip="To obtain UAST for given PsiElement of one of supported languages, use UastFacade class or UastContextKt.toUElement():"  >convert</a> each <code class="code " id="b751122d_156"  >PsiElement</code> to its corresponding UAST explicitly via <code class="code " id="b751122d_157"  >UastContext.toUElement()</code>.</p></section><section class="chapter"  ><h2 id="uast-performance-hints" data-toc="uast-performance-hints"  >UAST Performance Hints</h2><p id="b751122d_158" >UAST is not a zero-cost abstraction: <a href="https://youtrack.jetbrains.com/issue/KT-29856" id="b751122d_159"   data-external="true" rel="noopener noreferrer" >some methods</a> could be unexpectedly expensive for some languages, so be careful with optimizations because it could yield the opposite effect.</p><p id="b751122d_160" ><a href="#psi-to-uast-conversion" id="b751122d_161" data-tooltip="To obtain UAST for given PsiElement of one of supported languages, use UastFacade class or UastContextKt.toUElement():"  >Converting</a> to <code class="code " id="b751122d_162"  >UElement</code> also could require resolve for some languages in some cases, again, possibly unexpectedly expensive. Converting to UAST should be performed only when necessary. For instance, converting the whole <code class="code " id="b751122d_163"  >PsiFile</code> to <code class="code " id="b751122d_164"  >UFile</code> and then walk it solely to collect <code class="code " id="b751122d_165"  >UMethod</code> declarations is inefficient. Instead, walk the <code class="code " id="b751122d_166"  >PsiFile</code> and convert each encountered matching element to <code class="code " id="b751122d_167"  >UMethod</code> explicitly.</p><p id="b751122d_168" >UAST is lazy when you pass visitors to <code class="code " id="b751122d_169"  >UElement.accept()</code> or getting <code class="code " id="b751122d_170"  >UElement#uastParent</code>.</p><p id="b751122d_171" >For really hard performance optimisation consider using <code class="code " id="b751122d_172"  >UastLanguagePlugin.getPossiblePsiSourceTypes()</code> to pre-filter <code class="code " id="b751122d_173"  >PsiElement</code>s before converting them to UAST.</p></section><section class="chapter"  ><h2 id="uast-caveats" data-toc="uast-caveats"  >UAST Caveats</h2><section class="chapter"  ><h3 id="uliteralexpression-should-not-be-used-for-strings" data-toc="uliteralexpression-should-not-be-used-for-strings"  >ULiteralExpression should not be used for strings</h3><p id="b751122d_174" ><a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/uast/uast-common/src/org/jetbrains/uast/expressions/ULiteralExpression.kt" id="b751122d_175"   data-external="true" rel="noopener noreferrer" ><code class="code " id="b751122d_176"  >ULiteralExpression</code></a> represents literal values like numbers, booleans, and string. Although string values are also literals, <code class="code " id="b751122d_177"  >ULiteralExpression</code> is not very handy to work with them. For instance, it doesn't handle Kotlin's string interpolations. To process string literals when evaluating their value or to perform language injection, use <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/uast/uast-common/src/org/jetbrains/uast/expressions/UInjectionHost.kt" id="b751122d_178"   data-external="true" rel="noopener noreferrer" ><code class="code " id="b751122d_179"  >UInjectionHost</code></a> instead.</p></section><section class="chapter"  ><h3 id="sourcepsi-and-javapsi-psi-and-uelement-as-psi" data-toc="sourcepsi-and-javapsi-psi-and-uelement-as-psi"  >sourcePsi and javaPsi, psi and UElement as PSI</h3><p id="b751122d_180" >For historical reasons, the relations between <code class="code " id="b751122d_181"  >UElement</code> and <code class="code " id="b751122d_182"  >PsiElement</code> are complicated. Some <code class="code " id="b751122d_183"  >UElement</code>s implement <code class="code " id="b751122d_184"  >PsiElement</code>; for instance, <code class="code " id="b751122d_185"  >UMethod</code> implements <code class="code " id="b751122d_186"  >PsiMethod</code>. It is strongly discouraged to use <code class="code " id="b751122d_187"  >UElement</code> as <code class="code " id="b751122d_188"  >PsiElement</code>, and Plugin DevKit provides a corresponding inspection (<span class="control" id="b751122d_189" >Plugin DevKit | Code | UElement as PsiElement usage</span>). This <span class="emphasis" id="b751122d_190" >&quot;implements&quot;</span> is considered deprecated and might be removed in the future.</p><p id="b751122d_191" >Also, there is <code class="code " id="b751122d_192"  >UElement#psi</code> property; it returns the same element as <code class="code " id="b751122d_193"  >javaPsi</code> or the <code class="code " id="b751122d_194"  >sourcePsi</code>. As it is hard to guess what will be returned, it is also deprecated.</p><p id="b751122d_195" >Thus <code class="code " id="b751122d_196"  >sourcePsi</code> and <code class="code " id="b751122d_197"  >javaPsi</code> should be the only ways to obtain <code class="code " id="b751122d_198"  >PsiElement</code> from <code class="code " id="b751122d_199"  >UElement</code>. See the <a href="#uast-to-psi-conversion" id="b751122d_200" data-tooltip="Sometimes it's required to get from the UElement back to sources of the underlying language. For that purpose, UElement#sourcePsi property returns the corresponding PsiElement of the original language."  >corresponding section</a>.</p></section><section class="chapter"  ><h3 id="should-i-use-umethod-or-psimethod-uclass-or-psiclass" data-toc="should-i-use-umethod-or-psimethod-uclass-or-psiclass"  >Should I use UMethod or PsiMethod, UClass or PsiClass ?</h3><p id="b751122d_201" >UAST provides a unified way to represent JVM compatible declarations via <code class="code " id="b751122d_202"  >UMethod</code>, <code class="code " id="b751122d_203"  >UField</code>, <code class="code " id="b751122d_204"  >UClass</code>, and so on. But at the same time, all JVM language plugins implement <code class="code " id="b751122d_205"  >PsiMethod</code>, <code class="code " id="b751122d_206"  >PsiClass</code>, and so on to be compatible with Java. These implementations could be <a href="#uast-to-psi-conversion" id="b751122d_207" data-tooltip="Sometimes it's required to get from the UElement back to sources of the underlying language. For that purpose, UElement#sourcePsi property returns the corresponding PsiElement of the original language."  >obtained</a> via <code class="code " id="b751122d_208"  >UElement#javaPsi</code> property.</p><p id="b751122d_209" >So the question is: &quot;What should I use to represent the Java-declaration in my code?&quot;. The answer is: We encourage using <code class="code " id="b751122d_210"  >PsiMethod</code>, <code class="code " id="b751122d_211"  >PsiClass</code> as common interfaces for Java-declarations regardless of the JVM language and discourage exposing the UAST interfaces in the API.</p><p id="b751122d_212" >Note: for method bodies, there are no such alternatives, so exposing, for instance, the <code class="code " id="b751122d_213"  >UExpression</code> is not discouraged. Still, consider exposing the raw <code class="code " id="b751122d_214"  >PsiElement</code> instead.</p></section><section class="chapter"  ><h3 id="uastpsi-tree-structure-mismatch" data-toc="uastpsi-tree-structure-mismatch"  >UAST/PSI Tree Structure Mismatch</h3><p id="b751122d_215" >UAST is an abstraction level on top of PSI of different languages and tries to build a unified tree (see <a href="#inspecting-uast-tree" id="b751122d_216" data-tooltip="To inspect UAST Tree, invoke internal action Tools | Internal Actions | UAST | Dump UAST Tree (By Each PsiElement)."  >Inspecting UAST Tree</a>). It leads to the fact that the tree structure could seriously diverge between UAST and original language, so no ancestor-descendant relation preserving is guaranteed.</p><p id="b751122d_217" >For instance, the results of:</p><div class="code-block" data-lang="kotlin"         >
generateSequence(uElement, UElement::uastParent).mapNotNull { it.sourcePsi }
generateSequence(uElement.sourcePsi) { it.parent }
</div><p id="b751122d_219" >could be different, not only in the number of elements, but also in their order.</p></section></section><section class="chapter"  ><h2 id="using-uast-in-plugins" data-toc="using-uast-in-plugins"  >Using UAST in Plugins</h2><p id="b751122d_220" >To register extensions applicable to UAST, specify <code class="code " id="b751122d_221"  >language=&quot;UAST&quot;</code> in <span class="filepath" id="b751122d_222" ><a href="plugin-configuration-file.html" id="b751122d_223" data-tooltip="Plugin configuration file contains all the information about the plugin, as well as all registered extensions, actions, listeners, etc."  >plugin.xml</a></span>.</p><section class="chapter"  ><h3 id="inspecting-uast-tree" data-toc="inspecting-uast-tree"  >Inspecting UAST Tree</h3><p id="b751122d_224" >To inspect UAST Tree, invoke <a href="enabling-internal.html" id="b751122d_225" data-tooltip="某些工具例如内部操作菜单, 只有在IntelliJ IDEA的内部模式启用时才能看到."  >internal action</a>.</p></section><section class="chapter"  ><h3 id="inspections" data-toc="inspections"  >Inspections</h3><p id="b751122d_227" >Use <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/java/java-analysis-api/src/com/intellij/codeInspection/AbstractBaseUastLocalInspectionTool.java" id="b751122d_228"   data-external="true" rel="noopener noreferrer" ><code class="code " id="b751122d_229"  >AbstractBaseUastLocalInspectionTool</code></a> as base class and specify <code class="code " id="b751122d_230"  >language=&quot;UAST&quot;</code> in registration. If inspection targets only a subset of default types (<code class="code " id="b751122d_231"  >UFile</code>, <code class="code " id="b751122d_232"  >UClass</code>, <code class="code " id="b751122d_233"  >UField</code>, and <code class="code " id="b751122d_234"  >UMethod</code>), specify <code class="code " id="b751122d_235"  >UElement</code>s as hints in overloaded constructor to improve performance.</p></section><section class="chapter"  ><h3 id="line-marker" data-toc="line-marker"  >Line Marker</h3><p id="b751122d_236" >Use <code class="code " id="b751122d_237"  >UastUtils.getUParentForIdentifier()</code> or <code class="code " id="b751122d_238"  >UAnnotationUtils.getIdentifierAnnotationOwner()</code> for annotations to obtain suitable &quot;identifier&quot; element (see <a href="line-marker-provider.html" id="b751122d_239" data-tooltip="Code: SimpleLineMarkerProvider"  >Line Marker Provider</a> for details).</p></section></section><div class="last-modified"> Last modified: 28 九月 2022</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="element-patterns.html">Element Patterns</a>   <a class="navigation-links__next" href="xml-dom-api.html">XML DOM API</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/storage/help-app/v5/app.js"></script></body></html>
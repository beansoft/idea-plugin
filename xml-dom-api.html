<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8">  <meta name="built-on" content="2022-09-29T19:15:56.7372297"><meta name="build-number" content="${buildNumber}">    <meta name="keywords" content="">  <title>XML DOM API | IntelliJ Platform Plugin SDK</title><script id="virtual-toc-data" type="application/json">[{"id":"abstract","level":0,"title":"Abstract","anchor":"#abstract"},{"id":"introduction","level":0,"title":"Introduction","anchor":"#introduction"},{"id":"building-the-model","level":0,"title":"Building the Model","anchor":"#building-the-model"},{"id":"working-with-the-dom","level":0,"title":"Working with the DOM","anchor":"#working-with-the-dom"},{"id":"building-a-dom-based-gui","level":0,"title":"Building a DOM-Based GUI","anchor":"#building-a-dom-based-gui"},{"id":"conclusion","level":0,"title":"Conclusion","anchor":"#conclusion"}]</script>   <link href="https://resources.jetbrains.com/storage/help-app/v5/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content="https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png"><!-- Open Graph --><meta property="og:title" content="XML DOM API | IntelliJ Platform Plugin SDK"/><meta property="og:description" content=""/><meta property="og:image" content="https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png"/><meta property="og:site_name" content="IntelliJ Platform Plugin SDK Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="https://plugins.jetbrains.com/docs/intellij/xml-dom-api.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@JBPlatform"><meta name="twitter:title" content="XML DOM API | IntelliJ Platform Plugin SDK"><meta name="twitter:description" content=""><meta name="twitter:creator" content="@JBPlatform"><meta name="twitter:image:src" content="https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png"><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "https://plugins.jetbrains.com/docs/intellij/xml-dom-api.html#webpage", "url": "https://plugins.jetbrains.com/docs/intellij/xml-dom-api.html", "name": "XML DOM API | IntelliJ Platform Plugin SDK", "description": "", "image": "https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "https://plugins.jetbrains.com/docs/intellij/#website", "url": "https://plugins.jetbrains.com/docs/intellij/", "name": "IntelliJ Platform Plugin SDK Help" }</script><!-- End Schema.org --></head>    <body data-id="xml_dom_api.md" data-main-title="XML DOM API" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="Part IV — PSI"  data-edit-url="https://github.com/JetBrains/intellij-sdk-docs/edit/main/topics/reference_guide/frameworks_and_external_apis/xml_dom_api.md"  >  <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>IntelliJ Platform Plugin SDK  Help</h3><div class="shortcuts-switcher"><label for="switch-shortcuts">Keymap:</label><select class="select _shortcuts" height="1" id="switch-shortcuts">      </select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="xml_dom_api.md" id="xml_dom_api.md"  >XML DOM API</h1><section class="chapter"  ><h2 id="abstract" data-toc="abstract"  >Abstract</h2><p id="51e735a5_559" >This article is intended for plugin writers who create custom web server integrations, or some UI for easy XML editing. It describes the <span class="emphasis" id="51e735a5_560" >Document Object Model</span> (DOM) in IntelliJ Platform - an easy way to work with DTD or Schema-based XML models. The following topics will be covered: working with DOM itself (reading/writing tags content, attributes, and subtags) and easy XML editing in the UI by connecting UI to DOM.</p><p id="51e735a5_561" >It's assumed that the reader is familiar with Java, Swing, IntelliJ Platform XML PSI (classes <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/xml-psi-api/src/com/intellij/psi/xml/XmlTag.java" id="51e735a5_562"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_563"  >XmlTag</code></a>, <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/xml-psi-api/src/com/intellij/psi/xml/XmlFile.java" id="51e735a5_564"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_565"  >XmlFile</code></a>, <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/xml-psi-api/src/com/intellij/psi/xml/XmlTagValue.java" id="51e735a5_566"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_567"  >XmlTagValue</code></a>, etc.), IntelliJ Platform plugin development basics (application and project components, file editors).</p></section><section class="chapter"  ><h2 id="introduction" data-toc="introduction"  >Introduction</h2><p id="51e735a5_568" >So, how to operate with XML from an IntelliJ Platform plugin? Usually, one has to take <code class="code " id="51e735a5_569"  >XmlFile</code>, get its root tag, and then find a required sub-tag by path. The path consists of tag names, each of them a string. Typing these everywhere is tedious and error-prone. Let's assume you have the following XML:</p><div class="code-block" data-lang="markup"         >
&lt;root&gt;
  &lt;foo&gt;
    &lt;bar&gt;42&lt;/bar&gt;
    &lt;bar&gt;239&lt;/bar&gt;
  &lt;/foo&gt;
&lt;/root&gt;
</div><p id="51e735a5_571" >Let's say you want to read the contents of the second bar element, namely, &quot;239&quot;.</p><p id="51e735a5_572" >It's <span class="emphasis" id="51e735a5_573" >not</span> correct to create chained calls like</p><div class="code-block" data-lang="java"         >
file.getDocument()
    .getRootTag()
    .findFirstSubTag(&quot;foo&quot;)
    .findSubTags(&quot;bar&quot;)[1]
    .getValue()
    .getTrimmedText();
</div><p id="51e735a5_575" >because each call here may return <code class="code " id="51e735a5_576"  >null</code>.</p><p id="51e735a5_577" >So the code would probably look like this:</p><div class="code-block" data-lang="java"         >
XmlFile file = ...;
XmlDocument document = file.getDocument();
if (document != null) {
  XmlTag rootTag = document.getRootTag();
  if (rootTag != null) {
    XmlTag foo = rootTag.findFirstSubTag(&quot;foo&quot;);
    if (foo != null) {
      XmlTag[] bars = foo.findSubTags(&quot;bar&quot;);
      if (bars.length &gt; 1) {
        String s = bars[1].getValue().getTrimmedText();
        // do something
      }
    }
  }
}
</div><p id="51e735a5_579" >Looks awful, doesn't it? But there's a better way to do the same thing. You just need to extend a special interface - <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/DomElement.java" id="51e735a5_580"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_581"  >DomElement</code></a>.</p><p id="51e735a5_582" >For example, let's create several interfaces:</p><div class="code-block" data-lang="java"         >
interface Root extends com.intellij.util.xml.DomElement {
  Foo getFoo();
}

interface Foo extends com.intellij.util.xml.DomElement {
  List&lt;Bar&gt; getBars();
}

interface Bar extends com.intellij.util.xml.DomElement {
  String getValue();
}
</div><p id="51e735a5_584" >Next, you should create a <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/DomFileDescription.java" id="51e735a5_585"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_586"  >DomFileDescription</code></a> class, pass to its constructor the root tag name and root element interface. Register it in <span class="filepath" id="51e735a5_587" ><a href="plugin-configuration-file.html" id="51e735a5_588" data-tooltip="Plugin configuration file contains all the information about the plugin, as well as all registered extensions, actions, listeners, etc."  >plugin.xml</a></span> using <code class="code " id="51e735a5_589"  >com.intellij.dom.fileMetaData</code> extension point and specify <code class="code " id="51e735a5_590"  >rootTagName</code> and <code class="code " id="51e735a5_591"  >domVersion</code>/<code class="code " id="51e735a5_592"  >stubVersion</code> attributes.</p><aside data-type="tip" class="prompt" data-title="" id="51e735a5_593" ><p id="51e735a5_594" >When targeting 2019.1 or earlier, use <code class="code " id="51e735a5_595"  >com.intellij.dom.fileDescription</code> extension point instead.</p></aside><p id="51e735a5_596" >You can now get the file element from <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/DomManager.java" id="51e735a5_597"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_598"  >DomManager</code></a>. To get the &quot;239&quot; value, you only have to write the following code:</p><div class="code-block" data-lang="java"         >
DomManager manager = DomManager.getDomManager(project);
Root root = manager.getFileElement(file).getRootElement();
List&lt;Bar&gt; bars = root.getFoo().getBars();
if (bars.size() &gt; 1) {
  String s = bars.get(1).getValue();
  // do something
}
</div><p id="51e735a5_600" >I suppose this looks a little nicer. You often work with your model in more than one place. Re-creating the model is too inefficient, so we cache it for you, and any subsequent calls to <code class="code " id="51e735a5_601"  >DomManager.getFileElement()</code> will return the same instance. So, it is useful to invoke this method just once, and then keep everywhere only the &quot;root&quot; object you've obtained. In this case, you won't need to repeat that scary first line, and the code will look even nicer.</p><p id="51e735a5_602" >It is also important to note that with this scenario we avoid potential <code class="code " id="51e735a5_603"  >NullPointerException</code>: our DOM guarantees that every method accessing a tag child will return a not-null element, even if the correspondingly-named sub-tag doesn't exist. That may seem strange at first glance, but it appears to be rather convenient. How does it work? Simple. Given those interfaces, DOM generates all the code for accessing correct subtags and creating model elements at runtime. The sub-tag names and element types are taken from method names, return types and method annotations, if any. In most cases annotations can be omitted, as in our example, but this is discussed further in this article anyway.</p><p id="51e735a5_604" >Now let us explore more thoroughly what the DOM can do, and look at possible ways of representing various XML concepts such as tag content, attributes or sub-tags. Later, we will discuss basic methods for working with the model, as well as cover more advanced functionality. Finally, we'll see how to easily create a UI editor for DOM model elements.</p></section><section class="chapter"  ><h2 id="building-the-model" data-toc="building-the-model"  >Building the Model</h2><section class="chapter"  ><h3 id="tag-content" data-toc="tag-content"  >Tag Content</h3><p id="51e735a5_605" >In XML PSI, tag content is referred to as tag value, so well do the same for consistency. To read and change a tag value, you have to add two methods (getter and setter) to your interface, like this:</p><div class="code-block" data-lang="java"         >
String getValue();
void setValue(String s);
</div><p id="51e735a5_607" >These method names (<code class="code " id="51e735a5_608"  >getValue</code> and <code class="code " id="51e735a5_609"  >setValue</code>) are standard, and they are used for accessing tag values by default. If you want to use custom method names for the same goal, you should annotate these methods with <code class="code " id="51e735a5_610"  >@TagValue</code>, for example:</p><div class="code-block" data-lang="java"         >
@TagValue
String getTagValue();

@TagValue
void setTagValue(String s);
</div><p id="51e735a5_612" >As you can see, our accessors work with <code class="code " id="51e735a5_613"  >String</code> values. This is natural, since XML represents a text format, and tag content is always text. But sometimes you may want to operate with integers, booleans, enums, or even class names (they, of course, will be represented as <code class="code " id="51e735a5_614"  >PsiClass</code>), and more generic Java types (<code class="code " id="51e735a5_615"  >PsiType</code>). In such cases, you just need to change the type in methods to the one you need, and everything will keep working correctly.</p><section class="chapter"  ><h4 id="custom-value-types" data-toc="custom-value-types"  >Custom Value Types</h4><p id="51e735a5_616" >If you operate with even more exotic types, you should tell DOM how to deal with them. First, annotate your accessor methods with the <code class="code " id="51e735a5_617"  >@Convert</code> annotation, and specify your own class that should extend the <code class="code " id="51e735a5_618"  >Converter&lt;T&gt;</code> class in the annotation. Here <code class="code " id="51e735a5_619"  >T</code> is your exotic type, while <code class="code " id="51e735a5_620"  >Converter&lt;T&gt;</code> is a thing that knows how to convert values between <code class="code " id="51e735a5_621"  >String</code> and <code class="code " id="51e735a5_622"  >T</code>. If the value cannot be converted (for example, &quot;foo&quot; is not convertible into <code class="code " id="51e735a5_623"  >Integer</code>), the converter may return <code class="code " id="51e735a5_624"  >null</code>. Please also note that your implementation should have a no-argument constructor.</p><p id="51e735a5_625" >Let us consider an interesting case when <code class="code " id="51e735a5_626"  >T</code> represents an enum value. Usually, the converter just searches for enum elements with the names specified in XML. But sometimes, for their names, you may need or want to use values that are not valid Java identifiers. For example, the CMP version in EJB may be &quot;1.x&quot; or &quot;2.x&quot;, but you can't create Java enums with such names. For such cases, let your enum implement <code class="code " id="51e735a5_627"  >NamedEnum</code> interface, and then name your enum elements as you wish. Now, just provide the <code class="code " id="51e735a5_628"  >getValue()</code> implementation that will return the right value to match with XML contents, and voilà! In our example, the code will look as follows:</p><div class="code-block" data-lang="java"         >
enum CmpVersion implements NamedEnum {
  CmpVersion_1_X (&quot;1.x&quot;),
  CmpVersion_2_X (&quot;2.x&quot;);

  private final String value;

  CmpVersion(String value) {
    this.value = value;
  }

  public String getValue() {
    return value;
  }
}
</div><p id="51e735a5_630" >As we have already mentioned, an XML tag may have lots of artifacts besides its value: there can be attributes, children, but rather often (e.g., according to DTD or Schema) it should have only the value. Of course, such tags also need a DOM element to associate with. And we provide such an element:</p><div class="code-block" data-lang="java"         >
interface GenericDomValue&lt;T&gt; {
  T getValue();
  void setValue(T t);

  @TagValue
  String getStringValue();

  @TagValue
  void setStringValue(String s);
}
</div><p id="51e735a5_632" >So, you can just specify a particular <code class="code " id="51e735a5_633"  >T</code> when using this interface - and everything will work. Methods that work with <code class="code " id="51e735a5_634"  >String</code> are provided for many reasons. For example, your <code class="code " id="51e735a5_635"  >T</code> is <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/java/java-psi-api/src/com/intellij/psi/PsiClass.java" id="51e735a5_636"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_637"  >PsiClass</code></a>. It would be useful to highlight invalid values in the UI. To get the value to highlight (the string from the XML file), we have the <code class="code " id="51e735a5_638"  >getStringValue()</code> method. The error message will be taken from the converter via <code class="code " id="51e735a5_639"  >getErrorMessage()</code>.</p></section></section><section class="chapter"  ><h3 id="attributes" data-toc="attributes"  >Attributes</h3><p id="51e735a5_640" >Attributes are also rather simple to deal with. You can read their values, set them, and operate with different types. So it's natural to create something like <code class="code " id="51e735a5_641"  >GenericDomValue&lt;T&gt;</code> and then work as usual. &quot;Something like&quot; will be an inheritor, as shown below:</p><div class="code-block" data-lang="java"         >
interface GenericAttributeValue&lt;T&gt; extends GenericDomValue&lt;T&gt; {
  XmlAttribute getXmlAttribute();
}
</div><p id="51e735a5_643" >Consider that you want to work with an attribute named <span class="emphasis" id="51e735a5_644" >some-class</span> having a value of type <code class="code " id="51e735a5_645"  >PsiClass</code>:</p><div class="code-block" data-lang="java"         >
@Attribute(&quot;some-class&quot;)
GenericAttributeValue&lt;PsiClass&gt; getMyAttributeValue();
</div><p id="51e735a5_647" >That's all! Now you can get/set values, resolve this <code class="code " id="51e735a5_648"  >PsiClass</code>, get its <code class="code " id="51e735a5_649"  >String</code> representation, etc. The name of the attribute will be taken from the method name (see next paragraph). If you name your method in a special way, you can even omit the annotation. For example:</p><div class="code-block" data-lang="java"         >
GenericAttributeValue&lt;PsiClass&gt; getSomeClass();
</div><p id="51e735a5_651" >The <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/DomNameStrategy.java" id="51e735a5_652"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_653"  >DomNameStrategy</code></a> interface specifies how to convert accessor names to XML element names. Or more precisely, not the full accessor names, but rather the names minus any &quot;get&quot;, &quot;set&quot; or &quot;is&quot; prefixes. The strategy class is specified in the <code class="code " id="51e735a5_654"  >@NameStrategy</code> annotation in any DOM element interface. Then any descendants and children of this interface will use this strategy. The default strategy is <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/HyphenNameStrategy.java" id="51e735a5_655"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_656"  >HyphenNameStrategy</code></a>, where words are delimited by hyphens (see sample above). Another common variant is <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/JavaNameStrategy.java" id="51e735a5_657"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_658"  >JavaNameStrategy</code></a> that capitalizes the first letter of each word, as in Java's naming convention. In our example, the attribute name would be &quot;someClass&quot;.</p><p id="51e735a5_659" >If attribute doesn't define a <code class="code " id="51e735a5_660"  >PsiClass</code>, but some other custom <code class="code " id="51e735a5_661"  >T</code> that needs a converter, you just need to specify the <code class="code " id="51e735a5_662"  >@Convert</code> annotation to the getter.</p><p id="51e735a5_663" >Please note that the attributes' getter method will never return <code class="code " id="51e735a5_664"  >null</code>, even if the attribute isn't specified in XML. Its <code class="code " id="51e735a5_665"  >getValue()</code>, <code class="code " id="51e735a5_666"  >getStringValue()</code> and <code class="code " id="51e735a5_667"  >getXmlAttribute()</code> methods will return <code class="code " id="51e735a5_668"  >null</code>, but the DOM interface instance will exist and be valid. If the element has an underlying attribute, this can be easily fixed (surely, only if you need that): just call the <code class="code " id="51e735a5_669"  >undefine()</code> method (defined in <code class="code " id="51e735a5_670"  >DomElement</code>), and the XML attribute disappears, while <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/GenericAttributeValue.java" id="51e735a5_671"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_672"  >GenericAttributeValue</code></a> remains valid.</p></section><section class="chapter"  ><h3 id="children-fixed-number" data-toc="children-fixed-number"  >Children: Fixed Number</h3><p id="51e735a5_673" >You may often deal with tags that have at most one sub-tag with the given name (e.g. <code class="code " id="51e735a5_674"  >&lt;ejb-name&gt;</code>, <code class="code " id="51e735a5_675"  >&lt;ejb-class&gt;</code> or <code class="code " id="51e735a5_676"  >&lt;cmp-field&gt;</code>) in tags defining entity EJBs. To work with such children, provide getters for them. These getters should have a return type that extends <code class="code " id="51e735a5_677"  >DomElement</code>:</p><div class="code-block" data-lang="java"         >
GenericDomValue&lt;String&gt; getEjbName();
GenericDomValue&lt;String&gt; getEjbClass();
CmpField getCmpField();
</div><p id="51e735a5_679" >There's also an annotation to designate such children explicitly: <code class="code " id="51e735a5_680"  >@SubTag</code>. Its &quot;value&quot; attribute contains a tag name. If it is not specified, the name is implied from the method name using the current name strategy.</p><p id="51e735a5_681" >Sometimes it is the sub-tag's presence that means something, rather than its content - <code class="code " id="51e735a5_682"  >&lt;unchecked&gt;</code> in EJB method permissions, for example. If it exists, then permissions are unchecked, otherwise checked. For such things one should create a special <code class="code " id="51e735a5_683"  >GenericDomValue&lt;Boolean&gt;</code> child. Usually its <code class="code " id="51e735a5_684"  >getValue()</code> returns <code class="code " id="51e735a5_685"  >true</code> if there's &quot;true&quot; in a tag value, <code class="code " id="51e735a5_686"  >false</code> if there's &quot;false&quot; in a tag value, and <code class="code " id="51e735a5_687"  >null</code> otherwise. In the <code class="code " id="51e735a5_688"  >@SubTag</code> annotation, you can specify the attribute like <code class="code " id="51e735a5_689"  >indicator=true</code>. In this case, <code class="code " id="51e735a5_690"  >getValue()</code> will return <code class="code " id="51e735a5_691"  >true</code> if the tag exists and <code class="code " id="51e735a5_692"  >false</code> otherwise.</p><p id="51e735a5_693" >Let's consider another interesting example inspired by EJB, where there is a relation that has two roles, each designating one relation end: first role and second role. Both are represented by tags with the same values. So, we could create a collection of role elements, and every time we access some role we would check if this collection has a sufficient number of elements. But one of the main purposes of the DOM is to eliminate unnecessary checks. So why can't we have a fixed (more than one) number of children with the same tag name? Let's have them!</p><div class="code-block" data-lang="java"         >
@SubTag(value = &quot;ejb-relationship-role&quot;, index = 0)
EjbRelationshipRole getEjbRelationshipRole1();

@SubTag(value = &quot;ejb-relationship-role&quot;, index = 1)
EjbRelationshipRole getEjbRelationshipRole2();
</div><p id="51e735a5_695" >The first method will return the DOM element for the first subtag named <code class="code " id="51e735a5_696"  >&lt;ejb-relationship-role&gt;</code>, and the second - for the second one. Hence, the term &quot;fixed number&quot; for such children. According to DTD or Schema, there should be a fixed number of subtags with the given name. Most often this fixed number is 1; in our case with the relations it is 2. Just like attributes, fixed-number children exist regardless of underlying tag existence. If you need to delete tags, it can be done with the help of the same <code class="code " id="51e735a5_697"  >undefine()</code> method.</p><p id="51e735a5_698" >For children of <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/GenericDomValue.java" id="51e735a5_699"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_700"  >GenericDomValue</code></a> type, you can also specify a converter, just as you can for attributes.</p></section><section class="chapter"  ><h3 id="children-collections" data-toc="children-collections"  >Children: Collections</h3><p id="51e735a5_701" >One more common case in DTD and Schemas is when children have the same tag name and a non-fixed upper limit in count. Their accessors differ from those of the fixed-number children in the following: the return result is <code class="code " id="51e735a5_702"  >Collection</code> or <code class="code " id="51e735a5_703"  >List</code> of a special type that extends <code class="code " id="51e735a5_704"  >DomElement</code>, and if you want to use name strategies, the method name must be in pluralized form. For example, in the EJB we would have the following method:</p><div class="code-block" data-lang="java"         >
List&lt;Entity&gt; getEntities();
</div><p id="51e735a5_706" >There's also an annotation <code class="code " id="51e735a5_707"  >@SubTagList</code> where you can explicitly specify the tag name.</p><p id="51e735a5_708" >Returned collections cannot be modified directly. To delete an element from a collection, just call <code class="code " id="51e735a5_709"  >undefine()</code> on this element. The tag will then be removed, and an element will become invalid (<code class="code " id="51e735a5_710"  >DomElement.isValid() == false</code>). Note that this behavior differs from that of fixed-number children and attributes: they are always valid, even after <code class="code " id="51e735a5_711"  >undefine()</code>. Again, unlike those children types, collection children always have valid underlying XML tags.</p><p id="51e735a5_712" >Adding elements is a bit harder. Since all DOM elements are created internally, you can't just pass some of your DOM elements to some method to add the element to the collection. In fact, you have to ask a parent element to add a child to the collection. In our example, it's done in the following way:</p><div class="code-block" data-lang="java"         >
Entity addEntity(int index);
</div><p id="51e735a5_714" >which adds an element to wherever you want, or</p><div class="code-block" data-lang="java"         >
Entity addEntity();
</div><p id="51e735a5_716" >which adds a new DOM element to the end of the collection. Please note the singular tense of the word &quot;Entity&quot;. That's because here we deal with one <code class="code " id="51e735a5_717"  >Entity</code> object, while in the collection getter we dealt with potentially many entities.</p><p id="51e735a5_718" >Now, you can do anything you want with the returned value: modify, define the tag's value, children, etc.</p><p id="51e735a5_719" >The last common case is also a collection, but one consisting of tags with different names that are arbitrarily mixed. To work with it, you should define collection getters for all tag names within the mixed collection, and then define an additional specially annotated getter:</p><div class="code-block" data-lang="java"         >
// &lt;foo&gt; elements
List&lt;Foo&gt; getFoos();

// &lt;bar&gt; elements
List&lt;Bar&gt; getBars();

// all &lt;foo&gt; and &lt;bar&gt; elements
@SubTagsList({ &quot;foo&quot;, &quot;bar&quot; })
List&lt;FooBar&gt; getMergedListOfFoosAndBars();
</div><p id="51e735a5_721" >The annotation here is mandatory - we cannot guess several tag names from one method name.</p><p id="51e735a5_722" >To add elements to such mixed collections, you should create &quot;add&quot; methods for each possible tag name:</p><div class="code-block" data-lang="java"         >
@SubTagsList(value = { &quot;foo&quot;, &quot;bar&quot; }, tagName = &quot;foo&quot;)
FooBar addFoo();

@SubTagsList(value = { &quot;foo&quot;, &quot;bar&quot; }, tagName = &quot;bar&quot;)
FooBar addBar(int index);
</div><p id="51e735a5_724" >The index parameter in the last example means the index in the merged collection, not in the collection of tags named &quot;bar&quot;.</p></section><section class="chapter"  ><h3 id="dynamic-definition" data-toc="dynamic-definition"  >Dynamic Definition</h3><p id="51e735a5_725" >You can extend existing DOM model at runtime by implementing <code class="code " id="51e735a5_726"  >com.intellij.util.xml.reflect.DomExtender&lt;T&gt;</code>. Register it in &quot;extenderClass&quot; attribute of <code class="code " id="51e735a5_727"  >com.intellij.dom.extender</code> extension point, where &quot;domClass&quot; specifies DOM class <code class="code " id="51e735a5_728"  >&lt;T&gt;</code> to be extended. <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/reflect/DomExtensionsRegistrar.java" id="51e735a5_729"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_730"  >DomExtensionsRegistrar</code></a> provides various methods to register dynamic attributes and children.</p><p id="51e735a5_731" >If the contributed elements depend on anything other than plain XML file content (used framework version, libraries in classpath, ...), make sure to return <code class="code " id="51e735a5_732"  >false</code> from <code class="code " id="51e735a5_733"  >DomExtender.supportsStubs()</code>.</p></section><section class="chapter"  ><h3 id="namespace-support" data-toc="namespace-support"  >Namespace Support</h3><p id="51e735a5_734" >Annotate DOM model with <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/Namespace.java" id="51e735a5_735"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_736"  >Namespace</code></a> and register namespace key mapping via <code class="code " id="51e735a5_737"  >DomFileDescription.registerNamespacePolicy()</code> from <code class="code " id="51e735a5_738"  >DomFileDescription.initializeFileDescription()</code>.</p></section><section class="chapter"  ><h3 id="ide-support" data-toc="ide-support"  >IDE Support</h3><p id="51e735a5_739" ><span class="emphasis" id="51e735a5_740" >Plugin DevKit</span> supports the following features for working with DOM related code:</p><ul class="list _ul" id="51e735a5_741"    ><li class="list__item" id="51e735a5_742" ><p><a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/DomElement.java" id="51e735a5_743"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_744"  >DomElement</code></a> - provide implicit usages for all DOM-related methods defined in inheriting classes (to suppress &quot;unused method&quot; warning)</p></li><li class="list__item" id="51e735a5_745" ><p><a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/DomElementVisitor.java" id="51e735a5_746"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_747"  >DomElementVisitor</code></a> - provide implicit usages for all DOM-related visitor methods defined in inheriting classes (to suppress &quot;unused method&quot; warning)</p></li></ul></section></section><section class="chapter"  ><h2 id="working-with-the-dom" data-toc="working-with-the-dom"  >Working with the DOM</h2><section class="chapter"  ><h3 id="class-choosers" data-toc="class-choosers"  >Class Choosers</h3><p id="51e735a5_748" >It often happens that a collection contains same-named tags that may have different structure or even be represented by different types in the DTD or Schema. As an example, JSF Managed Beans may be of three types. If a <code class="code " id="51e735a5_749"  >&lt;managed-bean&gt;</code> tag contains a <code class="code " id="51e735a5_750"  >&lt;map-entries&gt;</code> sub-tag, then the Managed Bean type is <code class="code " id="51e735a5_751"  >MapEntriesBean</code>. If it contains a <code class="code " id="51e735a5_752"  >&lt;list-entries&gt;</code> sub-tag - can you guess? Right - <code class="code " id="51e735a5_753"  >ListEntriesBean</code>! Otherwise, it's a <code class="code " id="51e735a5_754"  >PropertyBean</code> (all three interfaces extend <code class="code " id="51e735a5_755"  >ManagedBean</code>). And when we write <code class="code " id="51e735a5_756"  >List&lt;ManagedBean&gt; getManagedBeans()</code>, we expect to get not only a list where all elements are instances of the <code class="code " id="51e735a5_757"  >ManagedBean</code> interface, but a list where each element is of a certain type, i.e. <code class="code " id="51e735a5_758"  >MapEntriesBean</code>, <code class="code " id="51e735a5_759"  >ListEntriesBean</code>, or <code class="code " id="51e735a5_760"  >PropertyBean</code>.</p><p id="51e735a5_761" >In such cases, one should decide which interface the DOM element should actually implement (according to the given tag). This is achieved by extending the <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/TypeChooser.java" id="51e735a5_762"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_763"  >TypeChooser</code></a> abstract class:</p><div class="code-block" data-lang="java"         >
public abstract class TypeChooser {
  public abstract Type chooseType(XmlTag tag);
  public abstract void distinguishTag(XmlTag tag, Type aClass)
      throws IncorrectOperationException;
  public abstract Type[] getChooserTypes();
}
</div><p id="51e735a5_765" >Here, the first method (<code class="code " id="51e735a5_766"  >chooseType()</code>) does exactly what it is named after (chooses the particular type, most often it's a class). The second one (<code class="code " id="51e735a5_767"  >distinguishTag()</code>) acts in reverse: it modifies a tag so that when the element is read from an XML file next time (for example, after the user has closed and opened the project again), the newly created DOM element will implement the same interface and no model data will be lost. Finally, <code class="code " id="51e735a5_768"  >getChooserTypes()</code> just returns all the types that could be returned by <code class="code " id="51e735a5_769"  >chooseType()</code>.</p><p id="51e735a5_770" >To make your <code class="code " id="51e735a5_771"  >TypeChooser</code> work, register it in your overridden <code class="code " id="51e735a5_772"  >DomFileDescription.initializeFileDescription()</code> method by calling <code class="code " id="51e735a5_773"  >registerTypeChooser()</code>.</p></section><section class="chapter"  ><h3 id="useful-methods-of-domelement-and-dommanager" data-toc="useful-methods-of-domelement-and-dommanager"  >Useful Methods of DomElement and DomManager</h3><section class="chapter"  ><h4 id="psi-connection" data-toc="psi-connection"  >PSI Connection</h4><p id="51e735a5_774" >Of course, DOM is tightly connected to XML PSI, so there's always a way of getting the <code class="code " id="51e735a5_775"  >XmlTag</code> instance (which can be <code class="code " id="51e735a5_776"  >null</code> for fixed-number children and attributes) using the <code class="code " id="51e735a5_777"  >getXmlTag()</code> method. We remember that in <code class="code " id="51e735a5_778"  >GenericAttributeValue</code> there's also the <code class="code " id="51e735a5_779"  >getXmlAttribute()</code> method. In general case there is <code class="code " id="51e735a5_780"  >getXmlElement()</code> method. You can also get a DOM element by its underlying XML PSI element using the <code class="code " id="51e735a5_781"  >DomManager.getDomElement()</code> method.</p><p id="51e735a5_782" >If a DOM element has no underlying XML element, it can be created by calling <code class="code " id="51e735a5_783"  >ensureTagExists()</code>. To delete a tag, use the already known <code class="code " id="51e735a5_784"  >undefine()</code> method. This method will always delete the underlying XML element (tag or attribute). If the element was a collection's child, then neither it nor its entire subtree will be valid anymore.</p></section><section class="chapter"  ><h4 id="tree-structure" data-toc="tree-structure"  >Tree Structure</h4><p id="51e735a5_785" >In every normal tree, there's always a possibility to walk up. <code class="code " id="51e735a5_786"  >DomElement</code> is no exception. Method <code class="code " id="51e735a5_787"  >getParent()</code> just returns element's parent in tree.</p><p id="51e735a5_788" >The method <code class="code " id="51e735a5_789"  >&lt;T extends DomElement&gt; T getParentOfType(Class&lt;T&gt; requiredClass, boolean strict)</code> returns the tree ancestor of the given class. You can see the standard <span class="emphasis" id="51e735a5_790" >strict</span> parameter, that can return the DOM element itself, if it's <code class="code " id="51e735a5_791"  >false</code> and your current DOM element is an instance of <span class="emphasis" id="51e735a5_792" >requiredClass</span>.</p><p id="51e735a5_793" >Finally, <code class="code " id="51e735a5_794"  >getRoot()</code> will return the <code class="code " id="51e735a5_795"  >DomFileElement</code>, which is the root of every DOM tree.</p></section><section class="chapter"  ><h4 id="validity" data-toc="validity"  >Validity</h4><p id="51e735a5_796" >An element becomes invalid if it has been deleted explicitly or due to external PSI changes. Fixed-number children and attributes are meant to stay valid as long as possible, no matter what happens with XML. They can become invalid only if they have a collection tree ancestor that has been deleted.</p><p id="51e735a5_797" >Newly created DOM elements are always correct and valid, so their <code class="code " id="51e735a5_798"  >isValid()</code> methods will return <code class="code " id="51e735a5_799"  >true</code>.</p><p id="51e735a5_800" >Element validity is very important, since you cannot invoke any methods on invalid elements (except, of course, <code class="code " id="51e735a5_801"  >isValid()</code> itself).</p></section><section class="chapter"  ><h4 id="dom-reflection" data-toc="dom-reflection"  >DOM Reflection</h4><p id="51e735a5_802" >DOM also has a kind of reflection, called &quot;Generic Info&quot;. One would use it to be able to access children by tag names directly, instead of calling getter methods. See <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/reflect/DomGenericInfo.java" id="51e735a5_803"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_804"  >DomGenericInfo</code></a> interface and <code class="code " id="51e735a5_805"  >getGenericInfo()</code> methods in <code class="code " id="51e735a5_806"  >DomElement</code> and <code class="code " id="51e735a5_807"  >DomManager</code> for more information. There's also <code class="code " id="51e735a5_808"  >DomElement.getXmlElementName()</code> method that returns the name of a corresponding tag or attribute.</p></section><section class="chapter"  ><h4 id="presentation" data-toc="presentation"  >Presentation</h4><p id="51e735a5_809" ><code class="code " id="51e735a5_810"  >DomElement.getPresentation()</code> returns an instance of <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/ElementPresentation.java" id="51e735a5_811"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_812"  >ElementPresentation</code></a>, an interface that knows presentable element type, name, and sometimes even its icon. Presentations are actually obtained from presentation factory objects that, like <code class="code " id="51e735a5_813"  >ClassChooser</code>s, should be registered in <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/ElementPresentationManager.java" id="51e735a5_814"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_815"  >ElementPresentationManager</code></a> as early as possible. You can specify type name and icon for all elements of some class, ways of getting type name, icon and presentable name for particular objects. When not specified, presentable name is taken from the object itself, if it contains a method annotated with <code class="code " id="51e735a5_816"  >@NameValue</code> annotation, that returns <code class="code " id="51e735a5_817"  >String</code> or <code class="code " id="51e735a5_818"  >GenericValue</code>. If there's no such method, it will return <code class="code " id="51e735a5_819"  >null</code>. For <code class="code " id="51e735a5_820"  >DomElement</code>, there's another way to get this presentable name: <code class="code " id="51e735a5_821"  >DomElement.getGenericInfo().getElementName()</code>.</p></section><section class="chapter"  ><h4 id="events" data-toc="events"  >Events</h4><p id="51e735a5_822" >If you want to be notified on every change in the DOM model, add <code class="code " id="51e735a5_823"  >DomEventListener</code> to <code class="code " id="51e735a5_824"  >DomManager</code>. DOM supports the following events: tag value changed, element defined/undefined/changed, and collection child added/removed.</p></section><section class="chapter"  ><h4 id="highlighting-annotations" data-toc="highlighting-annotations"  >Highlighting Annotations</h4><p id="51e735a5_825" >The DOM supports error checking and highlighting. It's based on annotations which you add to the DOM element in a special place (don't confuse these annotations with the ones of Java 5 - they are very different). You need to implement the <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/highlighting/DomElementsAnnotator.java" id="51e735a5_826"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_827"  >DomElementAnnotator</code></a> interface, and override <code class="code " id="51e735a5_828"  >DomFileDescription.createAnnotator()</code> method, and create this annotator there. In <code class="code " id="51e735a5_829"  >DomElementsAnnotator.annotate(DomElement element, DomElementsProblemsHolder annotator)</code> you should report about all errors and warnings in the element's subtree to the annotator (<code class="code " id="51e735a5_830"  >DomElementsProblemsHolder.createProblem()</code>). You should return this annotator in the corresponding virtual method of the <code class="code " id="51e735a5_831"  >DomFileDescription</code>.</p></section><section class="chapter"  ><h4 id="automatic-highlighting-basicdomelementsinspection" data-toc="automatic-highlighting-basicdomelementsinspection"  >Automatic Highlighting (BasicDomElementsInspection)</h4><p id="51e735a5_832" >The following errors can be highlighted automatically by providing an instance of <code class="code " id="51e735a5_833"  >BasicDomElementsInspection</code>:</p><ul class="list _ul" id="51e735a5_834"    ><li class="list__item" id="51e735a5_835" ><p><code class="code " id="51e735a5_836"  >@Required</code> element missing or having empty text</p></li><li class="list__item" id="51e735a5_837" ><p>XML value cannot be converted by some <code class="code " id="51e735a5_838"  >Converter</code></p></li><li class="list__item" id="51e735a5_839" ><p>name is not unique while it should be</p></li></ul><p id="51e735a5_840" >The latter case requires you to specify the name getter with <code class="code " id="51e735a5_841"  >@NameValue</code> annotation. The checking uses the <code class="code " id="51e735a5_842"  >DomFileDescription.getIdentityScope()</code> method to get the element defining the root scope in which the name should be unique.</p><p id="51e735a5_843" >To suppress spellchecking annotate your DomElement with <code class="code " id="51e735a5_844"  >@com.intellij.spellchecker.xml.NoSpellchecking</code>.</p></section><section class="chapter"  ><h4 id="required-children" data-toc="required-children"  >Required Children</h4><p id="51e735a5_845" >There is a common case in error highlighting, when one needs to say, that some required sub-tag or attribute is missing. DOM will do this for you automatically, if you annotate the getter for that child with the <code class="code " id="51e735a5_846"  >@Required</code> annotation. For collection children getters, this annotation will mean that the collection should be not empty (corresponding to '+' sign in DTD). Also, when you create a new element that has required fixed-number or attribute children, their tags or attributes will also be created in XML.</p></section></section><section class="chapter"  ><h3 id="resolving" data-toc="resolving"  >Resolving</h3><p id="51e735a5_847" >Remember the interface <code class="code " id="51e735a5_848"  >GenericDomValue&lt;T&gt;</code> and its sub-interface <code class="code " id="51e735a5_849"  >GenericAttributeValue&lt;T&gt;</code>? Remember, that ANY class may be passed as <code class="code " id="51e735a5_850"  >T</code> - for example, let's interpret <code class="code " id="51e735a5_851"  >GenericDomValue&lt;PsiClass&gt;</code> as a reference to a class. Then we can always consider it as a reference to an object of class <code class="code " id="51e735a5_852"  >T</code>! With strings or enums, it is not a very useful idea, but we'll use it in another way. Very often XML has such a structure that an object is declared at some place, and is referenced at some other place (more precisely, in a tag or attribute value). So, if you want to create a method like <code class="code " id="51e735a5_853"  >GenericValue&lt;MyDomElement&gt; getMyDomElementReference()</code>, then you just have to specify a proper converter that will find an instance in your model of <code class="code " id="51e735a5_854"  >MyDomElement</code> with the name specified in the <code class="code " id="51e735a5_855"  >GenericDomValue</code>.</p><p id="51e735a5_856" >That's the core idea. Since creating such converters is quite boring, we've done it for you. You don't have to annotate reference getters at all, as the name resolution will be made automatically. Elements will be searched by name, and the name will be taken from the method annotated with <code class="code " id="51e735a5_857"  >@NameValue</code>. The converter used is <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/DomResolveConverter.java" id="51e735a5_858"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_859"  >DomResolveConverter</code></a>. Its constructor takes a parameter, so it can't be referenced in <code class="code " id="51e735a5_860"  >@Convert</code> annotation, but its subclasses (if you create them) - can. If you still want to specify explicitly that your reference to <code class="code " id="51e735a5_861"  >DomElement</code> should be resolved &quot;model-wide&quot;, use the <code class="code " id="51e735a5_862"  >@Resolve</code> annotation parameterized with the desired class. The resolution scope will be taken from the <code class="code " id="51e735a5_863"  >DomFileDescription.getResolveScope()</code>.</p><p id="51e735a5_864" >In addition to the above, auto-resolving in DOM also provides some features in your XML text editor: error highlighting, completion, Find Usages, Rename Refactoring... Unresolved references will be highlighted, and even completed. If you want to create a custom converter and want to have this code insight with it, you should extend not only the <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/Converter.java" id="51e735a5_865"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_866"  >Converter</code></a> but <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/ResolvingConverter.java" id="51e735a5_867"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_868"  >ResolvingConverter</code></a>. It has one more method <code class="code " id="51e735a5_869"  >getVariants()</code>, where you'll have to provide the collection consisting of all targets your reference may resolve to. Those familiar with <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/platform/core-api/src/com/intellij/psi/PsiReference.java" id="51e735a5_870"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_871"  >PsiReference</code></a> will recognize the similarities here.</p><p id="51e735a5_872" >If you need to choose a <code class="code " id="51e735a5_873"  >Converter</code> depending on other values (e.g. in a sibling/parent element) or any runtime condition (e.g. presence or version of a library), you can use <code class="code " id="51e735a5_874"  >WrappingConverter</code>. See also <code class="code " id="51e735a5_875"  >GenericDomValueConvertersRegistry</code> for managing an extensible registry of available Converters to choose from.</p></section><section class="chapter"  ><h3 id="mock-and-stable-elements" data-toc="mock-and-stable-elements"  >Mock and Stable Elements</h3><p id="51e735a5_876" >Your DOM elements do not have to be tied to a physical file. <code class="code " id="51e735a5_877"  >DomManager.createMockElement()</code> will help you to create a virtual element of a given class with the given module. An element may be physical or not. 'Physical' here means that DOM will create a mock document for it, so you can enjoy <span class="control" id="51e735a5_878" >Undo</span> functionality if you pass this document to the right place in the file editor.</p><p id="51e735a5_879" ><code class="code " id="51e735a5_880"  >DomElement.copyFrom()</code> allows you to copy information from one <code class="code " id="51e735a5_881"  >DomElement</code> to another. In fact, it just replaces XML tags, and all the old data is lost. Nevertheless, the element's fixed-number children don't become invalid. They only contain new tag values, attribute values, etc. The tree is actually rather conservative.</p><p id="51e735a5_882" >The combination of <code class="code " id="51e735a5_883"  >createMockElement()</code> and <code class="code " id="51e735a5_884"  >copyFrom()</code> is useful for editing element contents in dialogs. You create a mock copy of an element, work with it in the dialog and then, if the user doesn't cancel, copy the element back to the main model. Since it's a common case, a special shortcut method has been created in <code class="code " id="51e735a5_885"  >DomElement</code>, called <code class="code " id="51e735a5_886"  >createMockCopy()</code>.</p><p id="51e735a5_887" >IntelliJ Platform's XML parser is incremental: changes in a text do not cause the whole file to be reparsed. But you should keep in mind that this rule may sometimes not work correctly. For example, your DOM elements can unexpectedly become broken as a result of manual editing of the XML file (even if it didn't happen inside those elements). If a file editor depends on such a broken element, this can lead to closing the tab, which isn't very nice from the user's point of view. For example, suppose you have an entity bean named &quot;SomeEntity&quot;. You open an editor for it, then you go into the XML, change the tag name from entity to session, and then back to entity. Of course, no DOM element can survive after such blasphemy. But notwithstanding, you still want your editor to stay open! Well, there is a solution, and it's called <code class="code " id="51e735a5_888"  >DomManager.createStableValue(Factory factory)</code>. This method creates a DOM element that delegates all its functionality to some real element (returned from the factory parameter). As soon as that real element becomes invalid, the factory is called once more, and if it returns something valid, it becomes the new delegate. And so on... In the example with EJB, the factory would once again look for an Entity Bean named &quot;SomeEntity&quot;.</p><p id="51e735a5_889" >Stable DOM elements also implement the <code class="code " id="51e735a5_890"  >StableElement</code> interface, which has the following methods:</p><ul class="list _ul" id="51e735a5_891"    ><li class="list__item" id="51e735a5_892" ><p><code class="code " id="51e735a5_893"  >DomElement getWrappedElement()</code> - just returns the current element to which all method calls are delegated;</p></li><li class="list__item" id="51e735a5_894" ><p><code class="code " id="51e735a5_895"  >void invalidate()</code> - makes the wrapped element invalid. Any following method call will cause the factory to create a new delegate;</p></li><li class="list__item" id="51e735a5_896" ><p><code class="code " id="51e735a5_897"  >void revalidate()</code> - calls the factory, and if it returns something new (i.e. not the same as the current wrapped element) invalidates the old value and adopts the new one.</p></li></ul></section><section class="chapter"  ><h3 id="visitor" data-toc="visitor"  >Visitor</h3><p id="51e735a5_898" >Visitor is a very common design pattern. DOM model also has a visitor, and it's called <code class="code " id="51e735a5_899"  >DomElementVisitor</code>. The <code class="code " id="51e735a5_900"  >DomElement</code> interface has methods <code class="code " id="51e735a5_901"  >accept()</code> and <code class="code " id="51e735a5_902"  >acceptChildren()</code> that take this visitor as a parameter. If you look at the interface <code class="code " id="51e735a5_903"  >DomElementVisitor</code> itself, you may be surprised, since it has only one method: <code class="code " id="51e735a5_904"  >visitDomElement(DomElement)</code>. Where is the visitor pattern? Where are all those methods with names like <code class="code " id="51e735a5_905"  >visitT(T)</code> that are usually found in it? There are no such methods, because the actual interfaces (T's) aren't known to anyone except you. But when you instantiate the <code class="code " id="51e735a5_906"  >DomElementVisitor</code> interface, you may add there these <code class="code " id="51e735a5_907"  >visitT()</code> methods, and they will be called! You may even name them just <code class="code " id="51e735a5_908"  >visit()</code>, specify the type of the parameter, and everything will be fine. For example, if you have two DOM element classes - <code class="code " id="51e735a5_909"  >Foo</code> and <code class="code " id="51e735a5_910"  >Bar</code> - your visitor may look like this:</p><div class="code-block" data-lang="java"         >
class MyVisitor implements DomElementVisitor {
  void visitDomElement(DomElement element) {}
  void visitFoo(Foo foo) {}
  void visitBar(Bar bar) {}
}
</div></section><section class="chapter"  ><h3 id="implementation" data-toc="implementation"  >Implementation</h3><p id="51e735a5_912" >Sometimes you may want to extend your model with some functionality that isn't directly connected with XML, but relates to your program logic. And the most appropriate place for this functionality is the DOM element interface. What to do then?</p><p id="51e735a5_913" >The simplest case is when you want to add to your interface a method that returns exactly what some other getter in this element (or in one of its children) returns. You can easily write this helper method and annotate it with the <code class="code " id="51e735a5_914"  >@PropertyAccessor</code> annotation, in which you should specify the path consisting of property names (getter names without the &quot;get&quot; or &quot;is&quot; prefixes). For example, you can write:</p><div class="code-block" data-lang="java"         >
GenericDomValue&lt;String&gt; getVeryLongName();

@PropertyAccessor(&quot;very-long-name&quot;)
GenericDomValue&lt;String&gt; getName();
</div><p id="51e735a5_916" >In this case, the second method will return just the same as the first one. If there were &quot;foo.bar.name&quot; instead of &quot;very-long-name&quot; in the annotation, the system would actually call <code class="code " id="51e735a5_917"  >getFoo().getBar().getName()</code> and return the result to you. Such annotations are useful when you're extending some interface that is inconsistent with your model, or you try to extract a common super-interface from two model interfaces with differently named children that have the same sense (see <code class="code " id="51e735a5_918"  >&lt;ejb-ref&gt;</code> and <code class="code " id="51e735a5_919"  >&lt;ejb-local-ref&gt;</code>).</p><p id="51e735a5_920" >The case just described is simple, but rare. More often, you really have to incorporate some logic into your model. Then nothing except Java code helps you. And it will. Add the desired methods to your interface, then create an abstract class implementing the interface, and implement there only methods that you added manually and that are not directly connected to your XML model. Note that the class should have a constructor with no arguments.</p><p id="51e735a5_921" >Now you only have to let DOM know that you wish to use this implementation every time you're creating a model element that should implement the necessary interface. Simply register it using <code class="code " id="51e735a5_922"  >com.intellij.dom.implementation</code> extension point and DOM will generate at run-time the class that not only implements the needed interface, but also extends your abstract class.</p></section><section class="chapter"  ><h3 id="models-across-multiple-files" data-toc="models-across-multiple-files"  >Models Across Multiple Files</h3><p id="51e735a5_923" >Many frameworks require a set of XML configuration files (&quot;fileset&quot;) to work as one model, so resolving/navigation works across all related DOM files. Depending on implementation/plugin, providing filesets implicitly (using existing framework's setup in a project) or via user configuration (usually via dedicated <code class="code " id="51e735a5_924"  >Facet</code>) can be achieved.</p><p id="51e735a5_925" >Extend <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/model/impl/DomModelFactory.java" id="51e735a5_926"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_927"  >DomModelFactory</code></a> (or <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/model/impl/BaseDomModelFactory.java" id="51e735a5_928"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_929"  >BaseDomModelFactory</code></a> for non-<code class="code " id="51e735a5_930"  >Module</code> scope) and provide implementation of your <code class="code " id="51e735a5_931"  >DomModel</code>. Usually you will want to add searcher/utility methods to work with your <code class="code " id="51e735a5_932"  >DomModel</code> implementation. Example can be found in Struts 2 plugin (package <code class="code " id="51e735a5_933"  >com.intellij.struts2.dom.struts.model</code>).</p></section><section class="chapter"  ><h3 id="dom-stubs" data-toc="dom-stubs"  >DOM Stubs</h3><aside data-type="tip" class="prompt" data-title="" id="51e735a5_934" ><p id="51e735a5_935" >Please use it sparingly and only for heavily accessed parts in your DOM model, as it increases disk space usage/indexing run time.</p></aside><p id="51e735a5_936" >DOM elements can be stubbed, so (costly) access to XML/PSI is not necessary (see <a href="indexing-and-psi-stubs.html" id="51e735a5_937" data-tooltip="The indexing framework provides a quick way to locate specific elements, e.g., files containing a certain word or methods with a particular name, in large codebases. Plugin developers can use the existing indexes built by the IDE itself and build and use their own indexes."  >Indexing and PSI Stubs</a> for similar feature for custom languages). Performance relevant elements, tag or attribute getters can simply be annotated with <code class="code " id="51e735a5_938"  >@com.intellij.util.xml.Stubbed</code>. Set and increase <code class="code " id="51e735a5_939"  >stubVersion</code> of <code class="code " id="51e735a5_940"  >com.intellij.dom.fileMetaData</code> extension whenever you change <code class="code " id="51e735a5_941"  >@Stubbed</code> annotations usage in your DOM hierarchy to trigger proper rebuilding of Stubs during indexing.</p></section></section><section class="chapter"  ><h2 id="building-a-dom-based-gui" data-toc="building-a-dom-based-gui"  >Building a DOM-Based GUI</h2><aside data-type="tip" class="prompt" data-title="" id="51e735a5_942" ><p id="51e735a5_943" >This API is unmaintained and will likely be removed in future versions.</p></aside><section class="chapter"  ><h3 id="forms" data-toc="forms"  >Forms</h3><p id="51e735a5_944" >All forms that deal with DOM are organized in a special way. They support two main things: getting data from XML into the UI, and saving UI data to XML. The former is called resetting, the latter - committing. There's <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/ui/Committable.java" id="51e735a5_945"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_946"  >Committable</code></a> interface that has corresponding methods: <code class="code " id="51e735a5_947"  >commit()</code> and <code class="code " id="51e735a5_948"  >reset()</code>. There's also a way of structuring your forms into smaller parts, namely the Composite pattern: <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/ui/CompositeCommittable.java" id="51e735a5_949"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_950"  >CompositeCommittable</code></a>. Methods <code class="code " id="51e735a5_951"  >commit()</code> and <code class="code " id="51e735a5_952"  >reset()</code> are invoked automatically on editor tab switch or undo. So you only need to ensure that all your Swing structure is organized in a tree of <code class="code " id="51e735a5_953"  >CompositeCommittable</code>, and all the hard work will be done by the IDE.</p><p id="51e735a5_954" >DOM controls are special descendants of <code class="code " id="51e735a5_955"  >Committable</code>. All of them implement <code class="code " id="51e735a5_956"  >DomUIControl</code>. Note that they are not Swing components - they are only a way of connecting DOM model and Swing components. One end of the connection - the DOM element - is usually specified in the control's constructor. The other end - Swing component - can be obtained in 2 ways. The first is to ask DOM control to create it. But that is rather inconvenient if you want to create the forms in, say, IntelliJ IDEA's GUI Designer. In that case, you'll need the second way: ask the control to <code class="code " id="51e735a5_957"  >bind()</code> to an existing Swing component of a correct type (that depends on the type of value that you're editing). After that, your Swing components will be synchronized with DOM. They'll even highlight errors reported by <code class="code " id="51e735a5_958"  >DomElementsAnnotator</code>.</p><p id="51e735a5_959" >Sometimes you may need to do some work (enable or disable some components, change their values) after a particular DOM control is committed. Then you should define the <code class="code " id="51e735a5_960"  >addCommitListener()</code> method of that DOM control and override the <code class="code " id="51e735a5_961"  >CommitListener.afterCommit()</code> method. This method will be invoked inside the same write action as the main <code class="code " id="51e735a5_962"  >commit()</code>, so any changes you do in this method to the XML will be merged with the <code class="code " id="51e735a5_963"  >commit()</code> in the Undo queue.</p></section><section class="chapter"  ><h3 id="simple-controls" data-toc="simple-controls"  >Simple Controls</h3><p id="51e735a5_964" >With simple controls, you can edit <code class="code " id="51e735a5_965"  >GenericDomValue</code>: simple text, class names, enums and boolean values. These controls take a special object as a constructor parameter. This object should implement the <code class="code " id="51e735a5_966"  >DomWrapper</code> interface that knows how to set/get values to/from a DOM model.</p><p id="51e735a5_967" >We have three major DomWrapper's: <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/ui/DomFixedWrapper.java" id="51e735a5_968"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_969"  >DomFixedWrapper&lt;T&gt;</code></a> redirecting calls to <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/GenericDomValue.java" id="51e735a5_970"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_971"  >GenericDomValue&lt;T&gt;</code></a>, <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/ui/DomStringWrapper.java" id="51e735a5_972"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_973"  >DomStringWrapper</code></a> redirecting calls to string accessors of <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/GenericDomValue.java" id="51e735a5_974"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_975"  >GenericDomValue</code></a>, and <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/ui/DomCollectionWrapper.java" id="51e735a5_976"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_977"  >DomCollectionWrapper</code></a> that gets/sets values of the first element of the given <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/GenericDomValue.java" id="51e735a5_978"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_979"  >GenericDomValue</code></a> collection. Some controls (those having a text field as part of itself) take an additional boolean constructor parameter - <span class="emphasis" id="51e735a5_980" >commitOnEveryChange</span>, whose meaning is evident from the name. We don't recommend using it anywhere except small dialogs, because committing on every change slows down the system significantly.</p><p id="51e735a5_981" >Most often these controls are created by <code class="code " id="51e735a5_982"  >DomUIFactory.createControl(GenericDomValue)</code>. This method understands which control to create by using DOM reflection (<code class="code " id="51e735a5_983"  >DomGenericInfo</code>, as you probably remember). But sometimes you may want to create the controls directly. So let's look at the simple controls more closely.</p><section class="chapter"  ><h4 id="booleancontrol" data-toc="booleancontrol"  >BooleanControl</h4><p id="51e735a5_984" >It allows you to edit boolean values. The control is bound to <code class="code " id="51e735a5_985"  >JCheckBox</code>.</p><figure  id="51e735a5_986"><img alt="BooleanControl" title="BooleanControl" src="images/booleancontrol.gif"  class="" width="319" height="58"/></figure></section><section class="chapter"  ><h4 id="combocontrol" data-toc="combocontrol"  >ComboControl</h4><p id="51e735a5_987" >The control is bound to a non-editable <code class="code " id="51e735a5_988"  >JComboBox</code>, so it can be used to choose something from a limited set. One case of such a limited set is enum. Or it can be a constructor where you can provide a <code class="code " id="51e735a5_989"  >Factory&lt;List&lt;String&gt;&gt;</code>, and return from this factory anything you want (for example, a list of database names to choose from). By default, the wrong values (written in XML, but not present in the list you've given to the control) are displayed in red. Since it's common practice to specify custom <code class="code " id="51e735a5_990"  >CellRenderer</code> for combo boxes, the control has the <code class="code " id="51e735a5_991"  >isValidValue(String)</code> method. If it returns <code class="code " id="51e735a5_992"  >false</code> on the value you're rendering, you can highlight it in some way, to achieve the same result as the default renderer. Or you can just delegate to that renderer in your own way.</p><figure  id="51e735a5_993"><img alt="ComboControl" title="ComboControl" src="images/combocontrol.gif"  class="" width="277" height="93"/></figure></section><section class="chapter"  ><h4 id="booleanenumcontrol" data-toc="booleanenumcontrol"  >BooleanEnumControl</h4><p id="51e735a5_994" >Sometimes, when there are only 2 alternatives, it's convenient to use a checkbox instead of a combobox. This control is designed specially for such cases. While being (and being bound to) a checkbox, the control edits not just &quot;true&quot; or &quot;false&quot;, but any two String values, or two enum elements. In the last case, it has a boolean <span class="emphasis" id="51e735a5_995" >invertedOrder</span> parameter, to specify which element corresponds to the checked state. By default, <span class="emphasis" id="51e735a5_996" >invertedOrder</span> is set to <code class="code " id="51e735a5_997"  >false</code>, so the first element corresponds to the unchecked state, and the second - to the checked one. If you set the parameter to <code class="code " id="51e735a5_998"  >true</code>, the states will swap.</p></section></section><section class="chapter"  ><h3 id="editor-based-controls" data-toc="editor-based-controls"  >Editor-Based Controls</h3><p id="51e735a5_999" >Please note that editor-based controls are built on IntelliJ Platform's <code class="code " id="51e735a5_1000"  >Editor</code> instead of standard <code class="code " id="51e735a5_1001"  >JTextField</code>. Since there's currently no way to instantiate Editor directly through the Open API, controls are bound to special <code class="code " id="51e735a5_1002"  >JPanel</code> inheritors, and their <code class="code " id="51e735a5_1003"  >bind()</code> method adds the necessary content to those panels.</p><section class="chapter"  ><h4 id="textcontrol" data-toc="textcontrol"  >TextControl</h4><p id="51e735a5_1004" >This control allows you to edit simple string values. The control is bound to a <code class="code " id="51e735a5_1005"  >TextPanel</code> component. There's also an inheritor of that panel - <code class="code " id="51e735a5_1006"  >MultiLineTextPanel</code>. If you bind a <code class="code " id="51e735a5_1007"  >StringControl</code> to it, a big editor will appear on the screen. In case you don't have space for a big editor, bind it to a <code class="code " id="51e735a5_1008"  >BigTextPanel</code>. Then it will be filled with a text editor, and the browse button will be added to open a dialog with the big editor where you can type a longer string.</p></section><section class="chapter"  ><h4 id="psiclasscontrol" data-toc="psiclasscontrol"  >PsiClassControl</h4><p id="51e735a5_1009" >This is a one-line editor with a browse button that opens the standard class selection dialog. The control accepts class names only. It is bound to <code class="code " id="51e735a5_1010"  >PsiClassPanel</code>.</p><figure  id="51e735a5_1011"><img alt="PsiClassControl" title="PsiClassControl" src="images/psiclasscontrol.gif"  class="" width="551" height="69"/></figure></section><section class="chapter"  ><h4 id="psitypecontrol" data-toc="psitypecontrol"  >PsiTypeControl</h4><p id="51e735a5_1012" >This is almost the same as PsiClassControl, but allows entering not only class names, but also Java primitive types and even arrays. It is bound to <code class="code " id="51e735a5_1013"  >PsiTypePanel</code>.</p></section></section><section class="chapter"  ><h3 id="collection-control" data-toc="collection-control"  >Collection Control</h3><p id="51e735a5_1014" >There is a special table component where each row represents one collection child. It's called <code class="code " id="51e735a5_1015"  >DomCollectionControl&lt;T&gt;</code>, where <code class="code " id="51e735a5_1016"  >T</code> is your collection element type. To function properly, it needs <code class="code " id="51e735a5_1017"  >DomElement</code> (parent of the collection), some description of the collection (sub-tag name or a <code class="code " id="51e735a5_1018"  >DomCollectionChildDescription</code> from DOM reflection), and a <code class="code " id="51e735a5_1019"  >ColumnInfo</code> array. This can be passed to the constructor, or can be created in a <code class="code " id="51e735a5_1020"  >DomCollectionControl</code> inheritor, in an overridden method <code class="code " id="51e735a5_1021"  >createColumnInfos()</code>.</p><p id="51e735a5_1022" >What is a column info? It's just a somewhat more comfortable way to work with the table model. It uses Java 5 generics and is more object-oriented. So, it's named <code class="code " id="51e735a5_1023"  >ColumnInfo&lt;Item,Aspect&gt;</code>, where <code class="code " id="51e735a5_1024"  >Item</code> is a type variable corresponding to the type of elements in the collection, and <code class="code " id="51e735a5_1025"  >Aspect</code> is a type variable corresponding to this particular column information type: <code class="code " id="51e735a5_1026"  >String</code>, <code class="code " id="51e735a5_1027"  >PsiClass</code>, <code class="code " id="51e735a5_1028"  >Boolean</code>, etc. The basic things that a column knows are: column name, column class, reading value (Aspect <code class="code " id="51e735a5_1029"  >valueOf(Item)</code>), writing value (<code class="code " id="51e735a5_1030"  >setValue(Item item, Aspect aspect)</code>), cell renderer (<code class="code " id="51e735a5_1031"  >getRenderer(Item)</code>), cell &quot;editability&quot; (<code class="code " id="51e735a5_1032"  >isCellEditable(Item)</code>), cell editor (<code class="code " id="51e735a5_1033"  >getEditor(Item)</code>), etc.</p><p id="51e735a5_1034" >There are a lot of predefined column infos, so you'll probably never create a new one.</p><p id="51e735a5_1035" >First, if a collection child is a <code class="code " id="51e735a5_1036"  >GenericDomValue</code>, it's usually convenient to edit it directly in the table. For this, you may need one of the following classes: <code class="code " id="51e735a5_1037"  >StringColumnInfo</code>, <code class="code " id="51e735a5_1038"  >BooleanColumnInfo</code>, or more generic <code class="code " id="51e735a5_1039"  >GenericValueColumnInfo</code>. But such collections are encountered very rarely.</p><p id="51e735a5_1040" >A more common case is when a collection element is more complex and has several <code class="code " id="51e735a5_1041"  >GenericDomValue</code> children. Then one may create a column for each of those children. The appropriate column info is <code class="code " id="51e735a5_1042"  >ChildGenericValueColumnInfo&lt;T&gt;</code>. It will ask you for a <code class="code " id="51e735a5_1043"  >DomFixedChildDescription</code> (one more thing from DOM reflection), a renderer and an editor - nothing else. So, the main things left to customize are the renderer and the editor.</p><p id="51e735a5_1044" >As for the renderer, there are two main choices: <code class="code " id="51e735a5_1045"  >DefaultTableCellRenderer</code>, and IntelliJ Platform's <code class="code " id="51e735a5_1046"  >BooleanTableCellRenderer</code>. Editors are more complicated, but they closely resemble simple DOM controls.</p><p id="51e735a5_1047" ><code class="code " id="51e735a5_1048"  >BooleanTableCellEditor</code>, <code class="code " id="51e735a5_1049"  >DefaultCellEditor(JTextField)</code>, <code class="code " id="51e735a5_1050"  >ComboTableCellEditor</code>, etc. <code class="code " id="51e735a5_1051"  >DomUIFactory.createCellEditor()</code> will create any of them automatically (including the editor for <code class="code " id="51e735a5_1052"  >PsiClass</code>), so that you won't need to think about which one to select every time.</p><p id="51e735a5_1053" >Collection control is a complex control, so it's bound to a complex Swing component. It's called <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/ui/DomTableView.java" id="51e735a5_1054"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_1055"  >DomTableView</code></a>. It has a toolbar (you can override <code class="code " id="51e735a5_1056"  >DomTableView.getToolbarPosition()</code> to customize its location), with Add and Delete buttons. If you want, you may specify custom addition actions in <code class="code " id="51e735a5_1057"  >DomCollectionControl.createAdditionActions()</code> (it's recommended to extend <code class="code " id="51e735a5_1058"  >ControlAddAction</code>). If there is only one addition action, it will be invoked after pressing the Add button; if there are many, then a popup menu will be displayed. To change the removal policy, override the <code class="code " id="51e735a5_1059"  >DomCollectionControl.doRemove(List&lt;T&gt;)</code> method.</p><p id="51e735a5_1060" >The toolbar may also have an Edit button, if you specify that <code class="code " id="51e735a5_1061"  >DomCollectionControl.isEditable()</code>. To add a behavior to this button, override <code class="code " id="51e735a5_1062"  >DomCollectionControl.doEdit(T)</code>. There can also be a Help button, if you pass a non-null String <span class="emphasis" id="51e735a5_1063" >helpId</span> parameter while constructing your <code class="code " id="51e735a5_1064"  >DomTableView</code>.</p><p id="51e735a5_1065" >If there are no items in the collection, <code class="code " id="51e735a5_1066"  >DomTableView</code> may display a special text (<code class="code " id="51e735a5_1067"  >DomTableView.getEmptyPaneText()</code>), instead of an empty table.</p><p id="51e735a5_1068" >You can add your own popup menu to the control. Call the <code class="code " id="51e735a5_1069"  >DomTableView.installPopup()</code> method after construction, and pass a <code class="code " id="51e735a5_1070"  >DefaultActionGroup</code> with your popup actions.</p><p id="51e735a5_1071" >Tables can have single or multiple (default) row selection. If you want to change this behavior, override <code class="code " id="51e735a5_1072"  >DomTableView.allowMultipleRowsSelection()</code>.</p><figure  id="51e735a5_1073"><img alt="CollectionControl" title="CollectionControl" src="images/collectioncontrol.gif"  class="" width="189" height="167"/></figure></section><section class="chapter"  ><h3 id="ui-organization" data-toc="ui-organization"  >UI Organization</h3><p id="51e735a5_1074" >The easiest way to create a DOM-based UI form is to extend the <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/ui/BasicDomElementComponent.java" id="51e735a5_1075"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_1076"  >BasicDomElementComponent</code></a> class. This will require you to pass some DOM element to the constructor. Then you bind an IntelliJ IDEA GUI Designer form to your subclass and design a beautiful form there. You will surely want to bind some controls to DOM UI, in which case you should of course ensure that they have the right types. Finally, you should create some DOM controls in class' constructor and bind them. But you can create controls and bind them to the <code class="code " id="51e735a5_1077"  >DomElement</code>'s children - <code class="code " id="51e735a5_1078"  >GenericDomValue</code>'s automatically.</p><p id="51e735a5_1079" >Just name your components properly and call the <code class="code " id="51e735a5_1080"  >bindProperties()</code> method in the constructor. The field names should correspond to the getter names for the element's children. They may also be prefixed with &quot;my&quot;. Imagine that you have such DOM interface:</p><div class="code-block" data-lang="java"         >
public interface Converter extends DomElement {
  GenericDomValue&lt;String&gt; getConverterId();
  GenericDomValue&lt;PsiClass&gt; getConverterClass();
}
</div><p id="51e735a5_1082" >In this case, the UI form class can look like this:</p><div class="code-block" data-lang="java"         >
public class ConverterComponent extends BasicDomElementComponent&lt;Converter&gt; {
  private JPanel myRootPane;
  private TextPanel myConverterId;
  private PsiClassPanel myConverterClass;

  public ConverterComponent(Converter domElement) {
    super(domElement);
    bindProperties();
  }
}
</div><p id="51e735a5_1084" >All the fields here are now bound to the controls in the GUI form.</p><p id="51e735a5_1085" >Very often, you'll have to create your own file editor. Then, to use all the binding and undo functionality, it's suggested to inherit your <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/platform/analysis-api/src/com/intellij/openapi/fileEditor/FileEditorProvider.java" id="51e735a5_1086"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_1087"  >FileEditorProvider</code></a> from <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/ui/PerspectiveFileEditorProvider.java" id="51e735a5_1088"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_1089"  >PerspectiveFileEditorProvider</code></a>, create an instance of <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/ui/DomFileEditor.java" id="51e735a5_1090"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_1091"  >DomFileEditor</code></a> there, and pass a <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/xml/dom-openapi/src/com/intellij/util/xml/ui/BasicDomElementComponent.java" id="51e735a5_1092"   data-external="true" rel="noopener noreferrer" ><code class="code " id="51e735a5_1093"  >BasicDomElementComponent</code></a>. To easily create an editor with a caption at the top, like in our EJB and JSF, you may use the static method <code class="code " id="51e735a5_1094"  >DomFileEditor.createDomFileEditor()</code>. <code class="code " id="51e735a5_1095"  >DomFileEditor</code> automatically listens to all changes in the document corresponding to the given DOM element, and therefore refreshes your component on undo. If you want to listen to changes in additional documents, use the methods <code class="code " id="51e735a5_1096"  >addWatchedDocument()</code>, <code class="code " id="51e735a5_1097"  >removeWatchedDocument()</code>, <code class="code " id="51e735a5_1098"  >addWatchedElement()</code>, <code class="code " id="51e735a5_1099"  >removeWatchedElement()</code> in <code class="code " id="51e735a5_1100"  >DomFileEditor</code>.</p></section></section><section class="chapter"  ><h2 id="conclusion" data-toc="conclusion"  >Conclusion</h2><p id="51e735a5_1101" >Thank you for your time and attention. We hope you've found this article really useful. You are welcome to post your questions and comments to our <a href="https://intellij-support.jetbrains.com/hc/en-us/community/topics/200366979-IntelliJ-IDEA-Open-API-and-Plugin-Development" id="51e735a5_1102"   data-external="true" rel="noopener noreferrer" >Open API and Plugin Development Forum</a>.</p><section class="chapter"  ><h3 id="further-material" data-toc="further-material"  >Further Material</h3><p id="51e735a5_1103" >The following bundled open-source plugins make (heavy) use of DOM:</p><ul class="list _ul" id="51e735a5_1104"    ><li class="list__item" id="51e735a5_1105" ><p><a href="https://github.com/JetBrains/android" id="51e735a5_1106"   data-external="true" rel="noopener noreferrer" >Android</a></p></li><li class="list__item" id="51e735a5_1107" ><p><a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/plugins/ant" id="51e735a5_1108"   data-external="true" rel="noopener noreferrer" >Ant</a></p></li><li class="list__item" id="51e735a5_1109" ><p><a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/plugins/devkit/devkit-core" id="51e735a5_1110"   data-external="true" rel="noopener noreferrer" >Plugin DevKit</a></p></li><li class="list__item" id="51e735a5_1111" ><p><a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/plugins/maven" id="51e735a5_1112"   data-external="true" rel="noopener noreferrer" >Maven</a></p></li><li class="list__item" id="51e735a5_1113" ><p><a href="https://github.com/JetBrains/intellij-plugins/tree/master/struts2" id="51e735a5_1114"   data-external="true" rel="noopener noreferrer" >Struts 2</a> (Ultimate Edition)</p></li><li class="list__item" id="51e735a5_1115" ><p><a href="https://jb.gg/ipe?extensions=com.intellij.dom.fileMetaData" id="51e735a5_1116"   data-external="true" rel="noopener noreferrer" >IntelliJ Platform Explorer - OSS plugins using DOM</a></p></li></ul></section></section><div class="last-modified"> Last modified: 29 九月 2022</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="uast.html">UAST - Unified Abstract Syntax Tree</a>   <a class="navigation-links__next" href="editing.html">Editing</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/storage/help-app/v5/app.js"></script></body></html>
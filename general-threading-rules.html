<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8">  <meta name="built-on" content="2022-09-28T11:33:50.4084394"><meta name="build-number" content="${buildNumber}">    <meta name="keywords" content="">  <title>通用线程规则 | IntelliJ Platform Plugin SDK</title><script id="virtual-toc-data" type="application/json">[{"id":"498759a3_1","level":0,"title":"读-写锁","anchor":"#498759a3_1"},{"id":"invokelater","level":0,"title":"模态和 invokeLater()","anchor":"#invokelater"},{"id":"background-processes-and-processcanceledexception","level":0,"title":"Background Processes and ProcessCanceledException","anchor":"#background-processes-and-processcanceledexception"},{"id":"read-action-cancellability","level":0,"title":"Read Action Cancellability","anchor":"#read-action-cancellability"},{"id":"avoiding-ui-freezes","level":0,"title":"Avoiding UI Freezes","anchor":"#avoiding-ui-freezes"}]</script>   <link href="https://resources.jetbrains.com/storage/help-app/v5/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content="https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png"><!-- Open Graph --><meta property="og:title" content="通用线程规则 | IntelliJ Platform Plugin SDK"/><meta property="og:description" content=""/><meta property="og:image" content="https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png"/><meta property="og:site_name" content="IntelliJ Platform Plugin SDK Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="https://plugins.jetbrains.com/docs/intellij/general-threading-rules.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@JBPlatform"><meta name="twitter:title" content="通用线程规则 | IntelliJ Platform Plugin SDK"><meta name="twitter:description" content=""><meta name="twitter:creator" content="@JBPlatform"><meta name="twitter:image:src" content="https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png"><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "https://plugins.jetbrains.com/docs/intellij/general-threading-rules.html#webpage", "url": "https://plugins.jetbrains.com/docs/intellij/general-threading-rules.html", "name": "通用线程规则 | IntelliJ Platform Plugin SDK", "description": "", "image": "https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "https://plugins.jetbrains.com/docs/intellij/#website", "url": "https://plugins.jetbrains.com/docs/intellij/", "name": "IntelliJ Platform Plugin SDK Help" }</script><!-- End Schema.org --></head>    <body data-id="general_threading_rules.md" data-main-title="通用线程规则" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="Part II — Base Platform///fundamentals.md|基础知识"  data-edit-url="https://github.com/JetBrains/intellij-sdk-docs/edit/main/topics/basics/architectural_overview/general_threading_rules.md"  >  <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>IntelliJ Platform Plugin SDK  Help</h3><div class="shortcuts-switcher"><label for="switch-shortcuts">Keymap:</label><select class="select _shortcuts" height="1" id="switch-shortcuts">      </select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="general_threading_rules.md" id="general_threading_rules.md"  >通用线程规则</h1><section class="chapter"  ><h2 id="498759a3_1" data-toc="498759a3_1"  >读-写锁</h2><aside data-type="tip" class="prompt" data-title="" id="498759a3_2" ><p id="498759a3_3" ><a href="https://plugins.jetbrains.com/plugin/16815-thread-access-info" id="498759a3_4"   data-external="true" rel="noopener noreferrer" >Thread Access Info</a> 插件在调试器中可视化显示读/写锁访问以及线程信息.</p></aside><p id="498759a3_5" >通常, <span class="emphasis" id="498759a3_6" >IntelliJ Platform</span> 中与代码相关的数据结构由单个读取器/写入器锁管理.</p><p id="498759a3_7" >你不能在读写Action之外读取下列子系统中中的模型:</p><ul class="list _ul" id="498759a3_8"    ><li class="list__item" id="498759a3_9" ><p><a href="psi.html" id="498759a3_10" data-tooltip="The Program Structure Interface, commonly referred to as just PSI, is the layer in the IntelliJ Platform responsible for parsing files and creating the syntactic and semantic code model that powers so many of the platform's features."  >Program Structure Interface</a> (PSI)</p></li><li class="list__item" id="498759a3_11" ><p><a href="virtual-file-system.html" id="498759a3_12" data-tooltip="The Virtual File System (VFS) is a component of the IntelliJ Platform that encapsulates most of its activity for working with files represented as Virtual File."  >Virtual File System</a> (VFS)</p></li><li class="list__item" id="498759a3_13" ><p><a href="project-structure.html" id="498759a3_14" data-tooltip="This topic considers the concept of projects based on the IntelliJ Platform and related subjects, such as modules, facets, libraries, and SDK. The project structure and Java classes available to manage projects and modules are discussed."  >Project root model</a>.</p></li></ul><p id="498759a3_15" >任何线程都可以 <span class="control" id="498759a3_16" >读取</span> 数据. 从UI线程读取数据不需要任何特殊的努力. 但是,从任何其他线程执行的读取操作需要使用<code class="code " id="498759a3_17"  >ApplicationManager.getApplication().runReadAction()</code>或更短的<a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/platform/core-api/src/com/intellij/openapi/application/ReadAction.java" id="498759a3_18"   data-external="true" rel="noopener noreferrer" ><code class="code " id="498759a3_19"  >ReadAction</code></a> <code class="code " id="498759a3_20"  >run()</code>/<code class="code " id="498759a3_21"  >compute()</code>包装在读取操作中.</p><p id="498759a3_22" >对应的对象不会保证在多个并行读取操作中存活. 作为一个经验法则, 当启动读取操作时, 检查 PSI/VFS/项目/模块 对象是否还有效.</p><p id="498759a3_23" >只允许从UI线程<span class="control" id="498759a3_24" >写入</span>数据,并且写操作总是需要用<code class="code " id="498759a3_25"  >ApplicationManager.getApplication().runWriteAction()</code>或更短的<a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/platform/core-api/src/com/intellij/openapi/application/WriteAction.java" id="498759a3_26"   data-external="true" rel="noopener noreferrer" ><code class="code " id="498759a3_27"  >WriteAction</code></a> <code class="code " id="498759a3_28"  >run()</code>/<code class="code " id="498759a3_29"  >compute()</code>包装在一个写操作中.</p><p id="498759a3_30" >此外,只允许从写安全上下文修改模型,其中包括用户操作,来自它们的<code class="code " id="498759a3_31"  >invokeLater</code>调用(参见下一节). 您不能从UI渲染器或<code class="code " id="498759a3_32"  >SwingUtilities.invokeLater()</code>调用中修改PSI,VFS或项目模型.</p></section><section class="chapter"  ><h2 id="invokelater" data-toc="invokelater"  >模态和 invokeLater()</h2><p id="498759a3_33" >To pass control from a background thread to the <a href="https://docs.oracle.com/javase/tutorial/uiswing/concurrency/dispatch.html" id="498759a3_34"   data-external="true" rel="noopener noreferrer" >Event Dispatch Thread</a> (EDT), instead of the standard <code class="code " id="498759a3_35"  >SwingUtilities.invokeLater()</code>, plugins should use <code class="code " id="498759a3_36"  >ApplicationManager.getApplication().invokeLater()</code>. The latter API allows specifying the <span class="emphasis" id="498759a3_37" >modality state</span> (<a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/platform/core-api/src/com/intellij/openapi/application/ModalityState.java" id="498759a3_38"   data-external="true" rel="noopener noreferrer" ><code class="code " id="498759a3_39"  >ModalityState</code></a>) for the call, i.e., the stack of modal dialogs under which the call is allowed to execute:</p><section class="chapter"  ><h3 id="modalitystatenon-modal" data-toc="modalitystatenon-modal"  >ModalityState.NON_MODAL</h3><p id="498759a3_40" >The operation will be executed after all modal dialogs are closed. If any of the open (unrelated) projects displays a per-project modal dialog, the action will be performed after the dialog is closed.</p></section><section class="chapter"  ><h3 id="modalitystatestateforcomponent" data-toc="modalitystatestateforcomponent"  >ModalityState.stateForComponent()</h3><p id="498759a3_41" >The operation can be executed when the topmost shown dialog is the one that contains the specified component or is one of its parent dialogs.</p></section><section class="chapter"  ><h3 id="none-specified" data-toc="none-specified"  >None Specified</h3><p id="498759a3_42" ><code class="code " id="498759a3_43"  >ModalityState.defaultModalityState()</code> will be used. This is the optimal choice in most cases that uses the current modality state when invoked from UI thread. It has special handling for background processes started with <code class="code " id="498759a3_44"  >ProgressManager</code>: <code class="code " id="498759a3_45"  >invokeLater()</code> from such a process may run in the same dialog that the process started.</p></section><section class="chapter"  ><h3 id="modalitystateany" data-toc="modalitystateany"  >ModalityState.any()</h3><p id="498759a3_46" >The operation will be executed as soon as possible regardless of modal dialogs. Please note that modifying PSI, VFS, or project model is prohibited from such runnables.</p><p id="498759a3_47" >If a UI thread activity needs to access <a href="indexing-and-psi-stubs.html" id="498759a3_48" data-tooltip="The indexing framework provides a quick way to locate specific elements, e.g., files containing a certain word or methods with a particular name, in large codebases. Plugin developers can use the existing indexes built by the IDE itself and build and use their own indexes."  >file-based index</a> (e.g., it's doing any project-wide PSI analysis, resolves references, etc.), please use <code class="code " id="498759a3_49"  >DumbService.smartInvokeLater()</code>. That way, it is run after all possible indexing processes have been completed.</p></section></section><section class="chapter"  ><h2 id="background-processes-and-processcanceledexception" data-toc="background-processes-and-processcanceledexception"  >Background Processes and ProcessCanceledException</h2><p id="498759a3_50" >Background progresses are managed by <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/platform/core-api/src/com/intellij/openapi/progress/ProgressManager.java" id="498759a3_51"   data-external="true" rel="noopener noreferrer" ><code class="code " id="498759a3_52"  >ProgressManager</code></a> class, which has plenty of methods to execute the given code with a modal (dialog), non-modal (visible in the status bar), or invisible progress. In all cases, the code is executed on a background thread, which is associated with a <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/platform/core-api/src/com/intellij/openapi/progress/ProgressIndicator.java" id="498759a3_53"   data-external="true" rel="noopener noreferrer" ><code class="code " id="498759a3_54"  >ProgressIndicator</code></a> object. The current thread's indicator can be retrieved any time via <code class="code " id="498759a3_55"  >ProgressIndicatorProvider.getGlobalProgressIndicator()</code>.</p><p id="498759a3_56" >For visible progresses, threads can use <code class="code " id="498759a3_57"  >ProgressIndicator</code> to notify the user about current status: e.g., set text or visual fraction of the work done.</p><p id="498759a3_58" >Progress indicators also provide means to handle cancellation of background processes, either by the user (pressing the <span class="emphasis" id="498759a3_59" >Cancel</span> button) or from code (e.g., when the current operation becomes obsolete due to some changes in the project). The progress can be marked as canceled by calling <code class="code " id="498759a3_60"  >ProgressIndicator.cancel()</code>. The process reacts to this by calling <code class="code " id="498759a3_61"  >ProgressIndicator.checkCanceled()</code> (or <code class="code " id="498759a3_62"  >ProgressManager.checkCanceled()</code> if no indicator instance at hand). This call throws a special unchecked <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/platform/util/base/src/com/intellij/openapi/progress/ProcessCanceledException.java" id="498759a3_63"   data-external="true" rel="noopener noreferrer" ><code class="code " id="498759a3_64"  >ProcessCanceledException</code></a> if the background process has been canceled.</p><p id="498759a3_65" >All code working with PSI, or in other kinds of background processes, must be prepared for <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/platform/util/base/src/com/intellij/openapi/progress/ProcessCanceledException.java" id="498759a3_66"   data-external="true" rel="noopener noreferrer" ><code class="code " id="498759a3_67"  >ProcessCanceledException</code></a> being thrown from any point. This exception should never be logged but rethrown, and it'll be handled in the infrastructure that started the process.</p><p id="498759a3_68" >The <code class="code " id="498759a3_69"  >checkCanceled()</code> should be called often enough to guarantee the process's smooth cancellation. PSI internals have a lot of <code class="code " id="498759a3_70"  >checkCanceled()</code> calls inside. If a process does lengthy non-PSI activity, insert explicit <code class="code " id="498759a3_71"  >checkCanceled()</code> calls so that it happens frequently, e.g., on each <span class="emphasis" id="498759a3_72" >Nth</span> loop iteration.</p><aside data-type="tip" class="prompt" data-title="" id="498759a3_73" ><p id="498759a3_74" >Throwing <code class="code " id="498759a3_75"  >ProcessCanceledException</code> from <code class="code " id="498759a3_76"  >checkCanceled()</code> can be disabled for development (e.g. while debugging the code) with the  action. The action is available only if <a href="enabling-internal.html" id="498759a3_78" data-tooltip="某些工具例如内部操作菜单, 只有在IntelliJ IDEA的内部模式启用时才能看到."  >Internal Mode is enabled</a>.</p></aside></section><section class="chapter"  ><h2 id="read-action-cancellability" data-toc="read-action-cancellability"  >Read Action Cancellability</h2><p id="498759a3_79" >Background threads shouldn't take plain read actions for a long time. The reason is that if the UI thread needs a write action (e.g., the user types something), it must be acquired as soon as possible. Otherwise, the UI will freeze until all background threads have released their read actions.</p><p id="498759a3_80" >The best-known approach is to cancel background read actions whenever there's a write action about to occur, and restart that background read action later from scratch. Editor highlighting, code completion, Goto Class/File/... actions all work like this.</p><p id="498759a3_81" >To achieve that, the lengthy background operation is started with a <code class="code " id="498759a3_82"  >ProgressIndicator</code>, and a dedicated listener cancels that indicator when write action is initiated. The next time the background thread calls <code class="code " id="498759a3_83"  >checkCanceled()</code>, a <code class="code " id="498759a3_84"  >ProcessCanceledException</code> is thrown, and the thread should stop its operation (and finish the read action) as soon as possible.</p><p id="498759a3_85" >There are two recommended ways of doing this:</p><ul class="list _ul" id="498759a3_86"    ><li class="list__item" id="498759a3_87" ><p>If on UI thread, call <code class="code " id="498759a3_88"  >ReadAction.nonBlocking()</code> which returns <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/platform/core-api/src/com/intellij/openapi/application/NonBlockingReadAction.java" id="498759a3_89"   data-external="true" rel="noopener noreferrer" ><code class="code " id="498759a3_90"  >NonBlockingReadAction</code></a></p></li><li class="list__item" id="498759a3_91" ><p>If already in a background thread, use <code class="code " id="498759a3_92"  >ProgressManager.getInstance().runInReadActionWithWriteActionPriority()</code> in a loop, until it passes or the whole activity becomes obsolete.</p></li></ul><p id="498759a3_93" >In both approaches, always check at the start of each read action, if the objects are still valid, and if the whole operation still makes sense (i.e., not canceled by the user, the project isn't closed, etc.). With <code class="code " id="498759a3_94"  >ReadAction.nonBlocking()</code>, use <code class="code " id="498759a3_95"  >expireWith()</code> or <code class="code " id="498759a3_96"  >expireWhen()</code> for that.</p><p id="498759a3_97" >If the activity has to access <a href="indexing-and-psi-stubs.html" id="498759a3_98" data-tooltip="The indexing framework provides a quick way to locate specific elements, e.g., files containing a certain word or methods with a particular name, in large codebases. Plugin developers can use the existing indexes built by the IDE itself and build and use their own indexes."  >file-based index</a> (e.g., it's doing any project-wide PSI analysis, resolves references, etc.), use <code class="code " id="498759a3_99"  >ReadAction.nonBlocking(...).inSmartMode()</code>.</p></section><section class="chapter"  ><h2 id="avoiding-ui-freezes" data-toc="avoiding-ui-freezes"  >Avoiding UI Freezes</h2><section class="chapter"  ><h3 id="do-not-perform-long-operations-in-ui-thread" data-toc="do-not-perform-long-operations-in-ui-thread"  >Do not Perform Long Operations in UI Thread</h3><p id="498759a3_100" >In particular, don't traverse <a href="virtual-file-system.html" id="498759a3_101" data-tooltip="The Virtual File System (VFS) is a component of the IntelliJ Platform that encapsulates most of its activity for working with files represented as Virtual File."  >Virtual File System</a>, parse <a href="psi.html" id="498759a3_102" data-tooltip="The Program Structure Interface, commonly referred to as just PSI, is the layer in the IntelliJ Platform responsible for parsing files and creating the syntactic and semantic code model that powers so many of the platform's features."  >PSI</a>, resolve <a href="psi-references.html" id="498759a3_103" data-tooltip="A reference in a PSI tree is an object that represents a link from a usage of a particular element in the code to the corresponding declaration. Resolving a reference means locating the declaration to which a specific usage refers."  >references</a> or query <a href="indexing-and-psi-stubs.html" id="498759a3_104" data-tooltip="The indexing framework provides a quick way to locate specific elements, e.g., files containing a certain word or methods with a particular name, in large codebases. Plugin developers can use the existing indexes built by the IDE itself and build and use their own indexes."  >indexes/stubs</a>.</p><p id="498759a3_105" >There are still some cases when the platform itself invokes such expensive code (e.g., resolve in <code class="code " id="498759a3_106"  >AnAction.update()</code>), but these are being worked on. Meanwhile, please try to speed up what you can in your plugin, it'll be beneficial anyway, as it'll also improve background highlighting performance.</p><p id="498759a3_107" ><code class="code " id="498759a3_108"  >WriteAction</code>s currently have to happen on UI thread, so to speed them up, you can try moving as much as possible out of write action into a preparation step which can be then invoked in background (e.g., using <code class="code " id="498759a3_109"  >ReadAction.nonBlocking()</code>, see above).</p><p id="498759a3_110" >Don't do anything expensive inside event listeners. Ideally, you should only clear some caches. You can also schedule background processing of events, but be prepared that some new events might be delivered before your background processing starts, and thus the world might have changed by that moment or even in the middle of background processing. Consider using <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/platform/ide-core/src/com/intellij/util/ui/update/MergingUpdateQueue.java" id="498759a3_111"   data-external="true" rel="noopener noreferrer" ><code class="code " id="498759a3_112"  >MergingUpdateQueue</code></a> and <code class="code " id="498759a3_113"  >ReadAction.nonBlocking()</code> to mitigate these issues.</p><p id="498759a3_114" >Massive batches of VFS events can be pre-processed in background, see <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/platform/core-api/src/com/intellij/openapi/vfs/AsyncFileListener.java" id="498759a3_115"   data-external="true" rel="noopener noreferrer" ><code class="code " id="498759a3_116"  >AsyncFileListener</code></a> (2019.2 or later).</p></section></section><div class="last-modified"> Last modified: 28 九月 2022</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="disposers.html">Disposer and Disposable</a>   <a class="navigation-links__next" href="messaging-infrastructure.html">Messaging Infrastructure</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/storage/help-app/v5/app.js"></script></body></html>
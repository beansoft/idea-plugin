<!DOCTYPE html SYSTEM "about:legacy-compat"><html lang="en-US" data-colors-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8">  <meta name="built-on" content="2022-09-29T19:15:56.8092453"><meta name="build-number" content="${buildNumber}">    <meta name="keywords" content="">  <title>Disposer and Disposable | IntelliJ Platform Plugin SDK</title><script id="virtual-toc-data" type="application/json">[{"id":"automatically-disposed-objects","level":0,"title":"Automatically Disposed Objects","anchor":"#automatically-disposed-objects"},{"id":"the-disposer-singleton","level":0,"title":"The Disposer Singleton","anchor":"#the-disposer-singleton"},{"id":"implementing-the-disposable-interface","level":0,"title":"Implementing the Disposable Interface","anchor":"#implementing-the-disposable-interface"},{"id":"diagnosing-disposer-leaks","level":0,"title":"Diagnosing Disposer Leaks","anchor":"#diagnosing-disposer-leaks"}]</script>   <link href="https://resources.jetbrains.com/storage/help-app/v5/app.css" rel="stylesheet">   <link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><link rel="manifest" href="https://jetbrains.com/site.webmanifest"><link rel="mask-icon" href="https://jetbrains.com/safari-pinned-tab.svg" color="#000000"><meta name="msapplication-TileColor" content="#000000"/><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"/><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"/><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"/><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"/><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"/>  <meta name="image" content="https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png"><!-- Open Graph --><meta property="og:title" content="Disposer and Disposable | IntelliJ Platform Plugin SDK"/><meta property="og:description" content=""/><meta property="og:image" content="https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png"/><meta property="og:site_name" content="IntelliJ Platform Plugin SDK Help"/><meta property="og:type" content="website"/><meta property="og:locale" content="en_US"/><meta property="og:url" content="https://plugins.jetbrains.com/docs/intellij/disposers.html"/><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@JBPlatform"><meta name="twitter:title" content="Disposer and Disposable | IntelliJ Platform Plugin SDK"><meta name="twitter:description" content=""><meta name="twitter:creator" content="@JBPlatform"><meta name="twitter:image:src" content="https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png"><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json"> { "@context": "http://schema.org", "@type": "WebPage", "@id": "https://plugins.jetbrains.com/docs/intellij/disposers.html#webpage", "url": "https://plugins.jetbrains.com/docs/intellij/disposers.html", "name": "Disposer and Disposable | IntelliJ Platform Plugin SDK", "description": "", "image": "https://resources.jetbrains.com/storage/products/jetbrains/img/meta/preview.png", "inLanguage":"en-US" }</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json"> { "@type": "WebSite", "@id": "https://plugins.jetbrains.com/docs/intellij/#website", "url": "https://plugins.jetbrains.com/docs/intellij/", "name": "IntelliJ Platform Plugin SDK Help" }</script><!-- End Schema.org --></head>    <body data-id="disposers.md" data-main-title="Disposer and Disposable" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}"  data-template="article"  data-breadcrumbs="Part II — Base Platform///fundamentals.md|基础知识"  data-edit-url="https://github.com/JetBrains/intellij-sdk-docs/edit/main/topics/basics/disposers.md"  >  <div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>IntelliJ Platform Plugin SDK  Help</h3><div class="shortcuts-switcher"><label for="switch-shortcuts">Keymap:</label><select class="select _shortcuts" height="1" id="switch-shortcuts">      </select></div><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="disposers.md" id="disposers.md"  >Disposer and Disposable</h1><p id="6de817b9_139" >The IntelliJ Platform's <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/platform/util/src/com/intellij/openapi/util/Disposer.java" id="6de817b9_140"   data-external="true" rel="noopener noreferrer" ><code class="code " id="6de817b9_141"  >Disposer</code></a> facilitates resource cleanup. If a subsystem keeps a set of resources alive coincident with a parent object's lifetime, the subsystem's resources should be registered with the <code class="code " id="6de817b9_142"  >Disposer</code> to be released before or at the same time as the parent object.</p><p id="6de817b9_143" >The most common resource type managed by <code class="code " id="6de817b9_144"  >Disposer</code> is listeners, but there are other possible types:</p><ul class="list _ul" id="6de817b9_145"    ><li class="list__item" id="6de817b9_146" ><p>File handles, and database connections,</p></li><li class="list__item" id="6de817b9_147" ><p>Caches and other significant data structures.</p></li></ul><p id="6de817b9_148" >The <code class="code " id="6de817b9_149"  >Disposer</code> is a singleton that manages a tree of <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/platform/util/src/com/intellij/openapi/Disposable.java" id="6de817b9_150"   data-external="true" rel="noopener noreferrer" ><code class="code " id="6de817b9_151"  >Disposable</code></a> instances. A <code class="code " id="6de817b9_152"  >Disposable</code> is an interface for any object providing a <code class="code " id="6de817b9_153"  >Disposable.dispose()</code> method to release heavyweight resources after a specific lifetime.</p><p id="6de817b9_154" >The <code class="code " id="6de817b9_155"  >Disposer</code> supports chaining <code class="code " id="6de817b9_156"  >Disposables</code> in parent-child relationships.</p><section class="chapter"  ><h2 id="automatically-disposed-objects" data-toc="automatically-disposed-objects"  >Automatically Disposed Objects</h2><p id="6de817b9_157" >Many objects are disposed automatically by the platform if they implement the <code class="code " id="6de817b9_158"  >Disposable</code> interface. The most important type of such objects is <a href="plugin-services.html" id="6de817b9_159" data-tooltip="A service is a plugin component loaded on demand when your plugin calls the getService() method of corresponding ComponentManager instance (see Types). The IntelliJ Platform ensures that only one instance of a service is loaded even though it is called several times."  >services</a>. Application-level services are automatically disposed by the platform when the IDE is closed or the plugin providing the service is unloaded. Project-level services are disposed when the project is closed, or the plugin is unloaded.</p><p id="6de817b9_160" >Note that extensions registered in <span class="filepath" id="6de817b9_161" ><a href="plugin-configuration-file.html" id="6de817b9_162" data-tooltip="Plugin configuration file contains all the information about the plugin, as well as all registered extensions, actions, listeners, etc."  >plugin.xml</a></span> are <span class="emphasis" id="6de817b9_163" >not</span> automatically disposed. If an extension requires executing some code to dispose it, you need to define a service and to put the code in its <code class="code " id="6de817b9_164"  >dispose()</code> method or use it as a parent disposable.</p></section><section class="chapter"  ><h2 id="the-disposer-singleton" data-toc="the-disposer-singleton"  >The Disposer Singleton</h2><p id="6de817b9_165" >The primary purpose of the <a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/platform/util/src/com/intellij/openapi/util/Disposer.java" id="6de817b9_166"   data-external="true" rel="noopener noreferrer" ><code class="code " id="6de817b9_167"  >Disposer</code></a> singleton is to enforce the rule that <span class="emphasis" id="6de817b9_168" >a child <code class="code " id="6de817b9_169"  >Disposable</code> never outlives its parent</span>.</p><p id="6de817b9_170" >The <code class="code " id="6de817b9_171"  >Disposer</code> organizes <code class="code " id="6de817b9_172"  >Disposable</code> objects in a tree of parent-child relationships. The tree of <code class="code " id="6de817b9_173"  >Disposable</code> objects ensures the <code class="code " id="6de817b9_174"  >Disposer</code> releases children of a parent first.</p><p id="6de817b9_175" >See <a href="#implementing-the-disposable-interface" id="6de817b9_176" data-tooltip="Creating a class requires implementing the Disposable interface and defining the dispose() method."  >The Disposable Interface</a> for more information about creating <code class="code " id="6de817b9_177"  >Disposable</code> classes.</p><p id="6de817b9_178" >Registering a disposable is performed by calling <code class="code " id="6de817b9_179"  >Disposer.register()</code>:</p><div class="code-block" data-lang="java"         >
  Disposer.register(parentDisposable, childDisposable);
</div><section class="chapter"  ><h3 id="choosing-a-disposable-parent" data-toc="choosing-a-disposable-parent"  >Choosing a Disposable Parent</h3><p id="6de817b9_181" >To register a child <code class="code " id="6de817b9_182"  >Disposable</code>, a parent <code class="code " id="6de817b9_183"  >Disposable</code> of a suitable lifetime is used to establish the parent-child relationship. One of the parent <code class="code " id="6de817b9_184"  >Disposables</code> provided by the IntelliJ Platform can be chosen, or it can be another <code class="code " id="6de817b9_185"  >Disposable</code>.</p><p id="6de817b9_186" >Use the following guidelines to choose the correct parent:</p><ul class="list _ul" id="6de817b9_187"    ><li class="list__item" id="6de817b9_188" ><p>For resources required for a plugin's entire lifetime, use an application or project level <a href="plugin-services.html" id="6de817b9_189" data-tooltip="A service is a plugin component loaded on demand when your plugin calls the getService() method of corresponding ComponentManager instance (see Types). The IntelliJ Platform ensures that only one instance of a service is loaded even though it is called several times."  >service</a>.</p></li><li class="list__item" id="6de817b9_190" ><p>For resources required while a <a href="dialog-wrapper.html" id="6de817b9_191" data-tooltip="The DialogWrapper is the base class which is supposed to be used for all modal dialogs (and some non-modal dialogs) shown in IntelliJ Platform."  >dialog</a> is displayed, use <code class="code " id="6de817b9_192"  >DialogWrapper.getDisposable()</code>.</p></li><li class="list__item" id="6de817b9_193" ><p>For resources required while a <a href="tool-windows.html" id="6de817b9_194" data-tooltip="Tool windows are child windows of the IDE used to display information. These windows generally have their own toolbars (referred to as tool window bars) along the outer edges of the main window containing one or more tool window buttons, which activate panels displayed on the left,…"  >tool window</a> tab is displayed, pass your instance implementing <code class="code " id="6de817b9_195"  >Disposable</code> to <code class="code " id="6de817b9_196"  >Content.setDisposer()</code>.</p></li><li class="list__item" id="6de817b9_197" ><p>For resources with a shorter lifetime, create a disposable using <code class="code " id="6de817b9_198"  >Disposer.newDisposable()</code> and dispose it manually using <code class="code " id="6de817b9_199"  >Disposable.dispose()</code>. Note that it's always best to specify a parent for such a disposable (e.g., a project-level service), so that there is no memory leak if the <code class="code " id="6de817b9_200"  >Disposable.dispose()</code> call is not reached because of an exception or a programming error.</p></li></ul><aside data-type="tip" class="prompt" data-title="" id="6de817b9_201" ><p id="6de817b9_202" >Even though <code class="code " id="6de817b9_203"  >Application</code> and <code class="code " id="6de817b9_204"  >Project</code> implement <code class="code " id="6de817b9_205"  >Disposable</code>, they must NEVER be used as parent disposables in plugin code. Disposables registered using those objects as parents will not be disposed when the plugin is unloaded, leading to memory leaks.</p><p id="6de817b9_206" >Inspection <span class="control" id="6de817b9_207" >Plugin DevKit | Code | Incorrect parentDisposable parameter</span> will highlight such problems.</p></aside><p id="6de817b9_208" >The <code class="code " id="6de817b9_209"  >Disposer</code> API's flexibility means that if the parent instance is chosen unwisely, the child may consume resources for longer than required. Continuing to use resources when they are no longer needed can be a severe source of contention due to leaving some zombie objects behind due to each invocation. An additional challenge is that these kinds of issues won't be reported by the regular leak checker utilities, because technically, it's not a memory leak from the test suite perspective.</p><p id="6de817b9_210" >For example, suppose a UI component created for a specific operation uses a project-level service as a parent disposable. In that case, the entire component will remain in memory after the operation is complete. This creates memory pressure and can waste CPU cycles on processing events that are no longer relevant.</p></section><section class="chapter"  ><h3 id="registering-listeners-with-parent-disposable" data-toc="registering-listeners-with-parent-disposable"  >Registering Listeners with Parent Disposable</h3><p id="6de817b9_211" >Many IntelliJ Platform APIs for registering listeners either require passing a parent disposable or have overloads that take a parent disposable. For example:</p><div class="code-block" data-lang="java"         >
public abstract class EditorFactory {
  // ...
  public abstract void addEditorFactoryListener(@NotNull EditorFactoryListener listener);
  public abstract void addEditorFactoryListener(@NotNull EditorFactoryListener listener, @NotNull Disposable parentDisposable);
  public abstract void removeEditorFactoryListener(@NotNull EditorFactoryListener listener);
}
</div><p id="6de817b9_213" >Methods with a <code class="code " id="6de817b9_214"  >parentDisposable</code> parameter automatically unsubscribe the listener when the corresponding parent disposable is disposed. Using such methods is always preferable to removing listeners explicitly from the <code class="code " id="6de817b9_215"  >dispose</code> method because it requires less code and is easier to verify for correctness.</p><p id="6de817b9_216" >To choose the correct parent disposable, use the guidelines from the previous section.</p><p id="6de817b9_217" >The same rules apply to <a href="messaging-infrastructure.html" id="6de817b9_218" data-tooltip="The purpose of this document is to introduce the messaging infrastructure available in the IntelliJ Platform to developers and plugin writers. It is intended to answer why, when and how to use it."  >message bus</a> connections. Always pass a parent disposable to <code class="code " id="6de817b9_219"  >MessageBus.connect()</code>, and make sure it has the shortest possible lifetime.</p></section><section class="chapter"  ><h3 id="determining-disposal-status" data-toc="determining-disposal-status"  >Determining Disposal Status</h3><p id="6de817b9_220" >You can use <code class="code " id="6de817b9_221"  >Disposer.isDisposed()</code> to check whether a <code class="code " id="6de817b9_222"  >Disposable</code> has already been disposed. This check is useful, for example, for an asynchronous callback to a <code class="code " id="6de817b9_223"  >Disposable</code> that may be disposed before the callback is executed. In such a case, the best strategy is usually to do nothing and return early.</p><aside data-type="tip" class="prompt" data-title="" id="6de817b9_224" ><p id="6de817b9_225" >Non-disposed objects shouldn't hold onto references to disposed objects, as this constitutes a memory leak. Once a <code class="code " id="6de817b9_226"  >Disposable</code> is released, it should be completely inactive, and there's no reason to refer to it anymore.</p></aside></section><section class="chapter"  ><h3 id="ending-a-disposable-lifecycle" data-toc="ending-a-disposable-lifecycle"  >Ending a Disposable Lifecycle</h3><p id="6de817b9_227" >A plugin can manually end a <code class="code " id="6de817b9_228"  >Disposable</code> lifecycle by calling <code class="code " id="6de817b9_229"  >Disposer.dispose(Disposable)</code>. This method handles recursively disposing of all the <code class="code " id="6de817b9_230"  >Disposable</code> child descendants as well.</p></section></section><section class="chapter"  ><h2 id="implementing-the-disposable-interface" data-toc="implementing-the-disposable-interface"  >Implementing the Disposable Interface</h2><p id="6de817b9_231" >Creating a class requires implementing the <code class="code " id="6de817b9_232"  >Disposable</code> interface and defining the <code class="code " id="6de817b9_233"  >dispose()</code> method.</p><p id="6de817b9_234" >In many cases, when the object implements <code class="code " id="6de817b9_235"  >Disposable</code> only to be used as a parent disposable, the method's implementation will be completely empty.</p><p id="6de817b9_236" >An example of a non-trivial <code class="code " id="6de817b9_237"  >dispose</code> implementation is shown below:</p><div class="code-block" data-lang="java"         >
  public class Foo&lt;T&gt; extends JBFoo implements Disposable {
      public Foo(@NotNull Project project, @NotNull String name, @Nullable FileEditor fileEditor, @NotNull Disposable parentDisposable) {
        this(project, name, fileEditor, InitParams.createParams(project), DetachedToolWindowManager.getInstance(project));
        Disposer.register(parentDisposable, this);
      }

     @Override
     public void dispose() {
       myFooManager.unregister(this);
       myDetachedToolWindowManager.unregister(myFileEditor);
       KeyboardFocusManager.getCurrentKeyboardFocusManager().removePropertyChangeListener(&quot;focusOwner&quot;, myMyPropertyChangeListener);
       setToolContext(null);
     }
  }
</div><p id="6de817b9_239" >A lot of code setting-up all the conditions requiring release in <code class="code " id="6de817b9_240"  >dispose()</code> has been omitted for simplicity.</p><p id="6de817b9_241" >Regardless, it illustrates the basic pattern, which is:</p><ul class="list _ul" id="6de817b9_242"    ><li class="list__item" id="6de817b9_243" ><p>In this case, the parent disposable is passed into the constructor,</p></li><li class="list__item" id="6de817b9_244" ><p>The <code class="code " id="6de817b9_245"  >Foo</code> disposable is registered as a child of <code class="code " id="6de817b9_246"  >parentDisposable</code> in the constructor.</p></li><li class="list__item" id="6de817b9_247" ><p>The <code class="code " id="6de817b9_248"  >dispose()</code> method consolidates the necessary release actions and will be called by the <code class="code " id="6de817b9_249"  >Disposer</code>.</p></li></ul><aside data-type="tip" class="prompt" data-title="" id="6de817b9_250" ><p id="6de817b9_251" >Never call <code class="code " id="6de817b9_252"  >Disposable.dispose()</code> directly because it bypasses the parent-child relationships established in <code class="code " id="6de817b9_253"  >Disposer</code>. Always call <code class="code " id="6de817b9_254"  >Disposer.dispose(Disposable)</code> instead.</p></aside></section><section class="chapter"  ><h2 id="diagnosing-disposer-leaks" data-toc="diagnosing-disposer-leaks"  >Diagnosing Disposer Leaks</h2><p id="6de817b9_255" >When the application exits, it performs a final sanity check to verify everything was disposed. If something was registered with the <code class="code " id="6de817b9_256"  >Disposer</code> but remains undisposed, the IntelliJ Platform reports it before shutting down.</p><p id="6de817b9_257" >In test and Debug mode (<code class="code " id="6de817b9_258"  >idea.disposer.debug</code> is set to <code class="code " id="6de817b9_259"  >on</code>), registering a <code class="code " id="6de817b9_260"  >Disposable</code> with the <code class="code " id="6de817b9_261"  >Disposer</code> also registers a stack trace for the object's allocation path. The <code class="code " id="6de817b9_262"  >Disposer</code> accomplishes this by creating a dummy <code class="code " id="6de817b9_263"  >Throwable</code> at the time of registration.</p><p id="6de817b9_264" >The following snippet represents the sort of &quot;memory leak detected&quot; error encountered in practice:</p><div class="code-block" data-lang="plaintext"         >
    java.lang.RuntimeException:
    Memory leak detected: &lt;Instance&gt; of class &lt;com.example.classtype&gt;
    See the cause for the corresponding Disposer.register() stacktrace:
        at ObjectTree.assertIsEmpty(ObjectTree.java:209)
        at Disposer.assertIsEmpty(Disposer.java:125)
        at Disposer.assertIsEmpty(Disposer.java:121)
        at ApplicationImpl.disposeSelf(ApplicationImpl.java:323)
        at ApplicationImpl.doExit(ApplicationImpl.java:780)
        …
    Caused by: java.lang.Throwable
        at ObjectTree.getOrCreateNodeFor(ObjectTree.java:101)
        at ObjectTree.register(ObjectTree.java:62)
        at Disposer.register(Disposer.java:81)
        at Disposer.register(Disposer.java:75)
        …
        at ProjectManagerEx.createProject(ProjectManagerEx.java:69)
        at NewProjectWizardDynamic.doFinish(NewProjectWizardDynamic.java:235)
        at DynamicWizard$1.run(DynamicWizard.java:433)
        at CoreProgressManager$5.run(CoreProgressManager.java:237)
        at CoreProgressManager$TaskRunnable.run(CoreProgressManager.java:563)
        …
</div><aside data-type="tip" class="prompt" data-title="" id="6de817b9_266" ><p id="6de817b9_267" >The first part of the callstack is unrelated to diagnosing the memory leak. Instead, pay attention to the second part of the call stack, after <code class="code " id="6de817b9_268"  >Caused by: java.lang.Throwable</code>.</p></aside><p id="6de817b9_269" >In this specific case, the IntelliJ Platform (<a href="https://github.com/JetBrains/intellij-community/tree/idea/222.3739.54/platform/core-impl/src/com/intellij/openapi/progress/impl/CoreProgressManager.java" id="6de817b9_270"   data-external="true" rel="noopener noreferrer" ><code class="code " id="6de817b9_271"  >CoreProgressManager</code></a>) started a task that contained the <code class="code " id="6de817b9_272"  >DynamicWizard</code> code. In turn, that code allocated a <code class="code " id="6de817b9_273"  >Project</code> that was never disposed by the time the application exited. That is a promising place to start digging.</p><p id="6de817b9_274" >The above memory leak was ultimately caused by failing to pass a <code class="code " id="6de817b9_275"  >Project</code> instance to a function responsible for registering it for disposal. Often the fix for a memory leak is as simple as understanding the memory scope of the object being allocated - usually a UI container, project, or application - and making sure a <code class="code " id="6de817b9_276"  >Disposer.register()</code> call is made appropriately for it.</p></section><div class="last-modified"> Last modified: 29 九月 2022</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom">  <a class="navigation-links__prev" href="fundamentals.html">基础知识</a>   <a class="navigation-links__next" href="general-threading-rules.html">通用线程规则</a>  </div></article><div id="disqus_thread"></div></div></section></main></div>  <script src="https://resources.jetbrains.com/storage/help-app/v5/app.js"></script></body></html>